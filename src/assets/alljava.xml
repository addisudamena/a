
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article lang="">
  <sect1>
  <para/>
  <para>     What is the difference between</para>
  <para>JDK and JRE?</para>
  <para> </para>
  <para>JDK stands for Java Development Kit. It contains the tools and libraries for development of Java programs. It also contains compilers and debuggers needed to compile Java program,</para>
  <para> </para>
  <para>JRE stands for Java Runtime Environment. This is included in JDK. JRE provides libraries and JVM that is required to run a Java program.</para>
  <para> </para>
  <para> </para>
  <para>     What is Java Virtual Machine</para>
  <para>(JVM)?</para>
  <para> </para>
  <para>Java Virtual Machine (JVM) is an abstract machine that executes Java Bytecode. There are different JVM for different hardware and software platforms. So JVM is platform dependent. JVM is responsible for loading, verifying and executing the Bytecode on a platform.</para>
  <para> </para>
  <para> </para>
  <para> </para>
  <para>What are the different types of memory areas allocated by JVM?</para>
  <para> </para>
  <para>In java, JVM allocates memory to different processes, methods and objects. Some of the memory areas allocated by JVM are:</para>
  <para> </para>
  <orderedlist>
    <listitem>
      <para>ClassLoader: It is a component of JVM used to load class files.</para>
    </listitem>
    <listitem>
      <para>Class (Method) Area: It stores per-class structures such as the runtime constant pool, field and method data, and the code for methods.</para>
    </listitem>
    <listitem>
      <para>Heap: Heap is created a runtime and it contains the runtime data area in which objects are allocated.</para>
    </listitem>
    <listitem>
      <para>Stack: Stack stores local variables and partial results at runtime. It also helps in method invocation and return value. Each thread creates a private JVM stack at the time of thread creation.</para>
    </listitem>
    <listitem>
      <para>Program Counter Register: This memory area contains the address of the Java virtual machine instruction that is currently being executed.</para>
    </listitem>
    <listitem>
      <para>Native Method Stack: This area is reserved for all the native methods used in the application.</para>
    </listitem>
  </orderedlist>
  <para> </para>
  <para>    What is JIT compiler?</para>
  <para> </para>
  <para>Just In Time compiler also known as JIT compiler is used for performance improvement in Java. It is enabled by default. It is compilation done at execution time rather earlier.</para>
  <para>Java has popularized the use of JIT compiler by including it in JVM.</para>
  <para> </para>
  <para> </para>
  <para>How Java platform is different from other platforms?</para>
  <para> </para>
  <para>Java is a platform independent language. Java compiler converts Java code in to byte code that can be interpreted by JVM. There are JVM written for almost all the popular platforms in the world.</para>
  <para> </para>
  <para>Java byte code can run on any supported platform in same way. Where as other languages require libraries compiled for a specific platform to run.</para>
  <para> </para>
  <para> </para>
  <para> </para>
  <para>Why people say that Java is 'write once and run anywhere' language?</para>
  <para> </para>
  <para>You can write Java code on Windows and compile it in Windows platform. The class and jar files that you get from Windows platform can run as it is on Unix environment. So it is a truly platform independent language.</para>
  <para> </para>
  <para>Behind all this portability is Java byte code. Byte code generated by Java compiler can be interpreted by any JVM. So it becomes much easier to write programs in Java and expect those to run on any platform.</para>
  <para> </para>
  <para>Java compiler javac compiles java code and JVM java runs that code.</para>
  <para> </para>
  <para> </para>
  <para>How does ClassLoader work in Java?</para>
  <para> </para>
  <para>In Java, ClassLoader is a class that is used to load files in JVM. ClassLoader loads files from their physical file locations e.g. Filesystem, Network location etc.</para>
  <para> </para>
  <para>There are three main types of ClassLoaders in Java.</para>
  <para> </para>
  <orderedlist>
    <listitem>
      <para>Bootstrap ClassLoader: This is the first ClassLoader. It loads classes from rt.jar file.</para>
    </listitem>
    <listitem>
      <para>Extension ClassLoader: It loads class files from jre/lib/ext location.</para>
    </listitem>
    <listitem>
      <para>Application ClassLoader: This ClassLoader depends on CLASSPATH to find the location of class files. If you specify your jars in CLASSPATH, then this ClassLoader will load them.</para>
    </listitem>
  </orderedlist>
  <para> </para>
  <para> </para>
  <para> </para>
  <para> </para>
  <para>Do you think ‘main’ used for main method is a keyword in Java?</para>
  <para> </para>
  <para>No, main is just a name of method. There can be multiple methods with same name main in a class file. It is not a keyword in Java.</para>
  <para> </para>
  <para>Can we write main method as public void static instead of public static void?</para>
  <para> </para>
  <para>No, you cannot write it like this.  Any method has to first specify the modifiers and then the return value. The order of modifiers can change.</para>
  <para> </para>
  <para>We can write static public void main() instead of public static void main().</para>
  <para> </para>
  <para> </para>
  <para> </para>
  <para>In Java, if we do not specify any value for local variables, then what will be the default value of the local variables?</para>
  <para> </para>
  <para>Java does not initialize local variables with any default value. So these variables will be just null by default.</para>
  <para> </para>
  <para>  Let say, we run a java class without passing any arguments. What will be the value of String array of arguments in Main method?</para>
  <para> </para>
  <para>By default, the value of String array of arguments is empty in Java. It is not null.</para>
  <para> </para>
  <para> </para>
  <para>What is the difference between byte and char data types in Java?</para>
  <para> </para>
  <para>Both byte and char are numeric data types in Java. They are used to represent numbers in a specific range.</para>
  <para> </para>
  <para>Major difference between them is that a byte can store raw binary data where as a char stores characters or text data.</para>
  <para> </para>
  <para>Usage of char is E.g. char ch = ‘x’;</para>
  <para> </para>
  <para>Byte values range from -128 to 127.</para>
  <para> </para>
  <para>A byte is made of 8 bits. But a char is made of 16 bits. So it is equivalent to 2 bytes.</para>
  <para> </para>
  <para> </para>
  </sect1>
  <sect1>
    <title>OOPS</title>
    <para> </para>
    <para> </para>
    <para>What are the main principles of Object Oriented Programming?</para>
    <para> </para>
    <para>Main principles of Object Oriented Programming (OOPS) are:</para>
    <orderedlist>
      <listitem>
        <para>Abstraction</para>
      </listitem>
      <listitem>
        <para>Encapsulation</para>
      </listitem>
      <listitem>
        <para>Inheritance</para>
      </listitem>
      <listitem>
        <para>Polymorphism</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>What is the difference between Object Oriented Programming language and Object Based Programming language?</para>
    <para> </para>
    <para>Object Oriented Programming languages like Java and C++ follow concepts of OOPS like- Encapsulation, Abstraction, Polymorphism and Inheritance etc.</para>
    <para> </para>
    <para>Object Based Programming languages follow some features of</para>
    <para>OOPS but they do not provide support for Polymorphism and Inheritance. Egg. JavaScript, VBScript etc.</para>
    <para> </para>
    <para>Object Based Programming languages provide support for Objects and you can build objects from constructor. They languages also support Encapsulation. These are also known as Prototype-oriented languages.</para>
    <para> </para>
    <para> </para>
    <para>In Java what is the default value of an object reference defined as an instance variable in an Object?</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>All the instance variable object references in Java are null.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>Why do we need constructor in Java?</para>
    <para> </para>
    <para>Java is an object-oriented language, in which we create and use objects. A constructor is a piece of code similar to a method. It is used to create an object and set the initial state of the object.</para>
    <para> </para>
    <para>A constructor is a special function that has same name as class name.</para>
    <para> </para>
    <para>Without a constructor, there is no other way to create an object.</para>
    <para> </para>
    <para>By default, Java provides a default constructor for every object. If we overload a constructor then we have to implement default constructor.</para>
    <para> </para>
    <para>Why do we need default constructor in Java classes?</para>
    <para> </para>
    <para>Default constructor is the no-argument constructor that is automatically generated by Java if no other constructor is defined.</para>
    <para> </para>
    <para>Java specification says that it will provide a default constructor if there is no overloaded constructor in a class. But it does not say anything about the scenario in which we write an overloaded constructor in a class.</para>
    <para> </para>
    <para>We need at least one constructor to create an object, that’s why Java provides a default constructor.</para>
    <para> </para>
    <para>When we have overloaded constructor, then Java assumes that we want some custom treatment in our code. Due to which it does not provide default constructor. But it needs default constructor as per the specification. So it gives error.</para>
    <para> </para>
    <para>What is the value returned by Constructor in Java?</para>
    <para> </para>
    <para>When we call a constructor in Java, it returns the object created by it. That is how we create new objects in Java.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Can we inherit a Constructor?</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>No, Java does not support inheritance of constructor.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Why constructors cannot be final, static, or abstract in Java?</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>If we set a method as final it means we do not want any class to override it. But the constructor (as per Java Language Specification) cannot be overridden. So there is no use of marking it final.</para>
    <para> </para>
    <para>If we set a method as abstract it means that it has no body and it should be implemented in a child class. But the constructor is called implicitly when the new keyword is used. Therefore it needs a body.</para>
    <para> </para>
    <para>If we set a method as static it means that it belongs to the class, but not a particular object. The constructor is always called to initialize an object. Therefore, there is no use of marking constructor static.</para>
  </sect1>
  <sect1>
    <title>Inheritance</title>
    <para> </para>
    <para> What is the purpose of ‘this’ keyword in java?</para>
    <para> </para>
    <para>In Java, ‘this’ keyword refers to current instance of the object.</para>
    <para> </para>
    <para>It is useful for differentiating between instance variables and local variables.</para>
    <para> </para>
    <para>It can be used to call constructors. Or it can be used to refer to the instance.</para>
    <para> </para>
    <para>In case of method overriding, this is used for falling the method of current class.</para>
    <para> </para>
    <para>Explain the concept of Inheritance?</para>
    <para> </para>
    <para>Inheritance is an important concept in Object Oriented Programming. Some objects share certain characteristics and behavior. By using Inheritance, we can put the common behavior and characteristics in a base class which also known as super class. And then all the objects with common behavior inherit from this base class.</para>
    <para> </para>
    <para>It is also represented by IS-A relationship.</para>
    <para> </para>
    <para>Inheritance promotes, code reuse, method overriding and polymorphism.</para>
    <para> </para>
    <para> </para>
    <para>Which class in Java is superclass of every other class?</para>
    <para> </para>
    <para>Java is an object oriented programming language. In Java, Object class is the superclass of every other class.</para>
    <para> </para>
    <para>Why Java does not support multiple inheritance?</para>
    <para> </para>
    <para>Multiple Inheritance means that a class can inherit behavior from two or more parent classes.</para>
    <para> </para>
    <para>The issue with Multiple Inheritance is that both the parent classes may have different implementation for the same method. So they have different ways of doing the same thing. Now which implementation should the child class choose?</para>
    <para> </para>
    <para>This leads to ambiguity in Multiple Inheritance. This is the main reason for Java not supporting Multiple Inheritance in implementation.</para>
    <para> </para>
    <para>Lets say you have a class TV and another class AtomBomb. Both have method switchOn() but only TV has switchOff() method. If your class inherits from both these classes then you have an issue that you can switchOn() both parents, but switchOff will only switchOff() TV.</para>
    <para> </para>
    <para>But you can implement multiple interfaces in Java.</para>
    <para> </para>
    <para> </para>
    <para>In OOPS, what is meant by composition?</para>
    <para> </para>
    <para>Composition is also known as “has-a” relationship. In composition, “has-a” relation relates two classes. E.g. Class Car has a steering wheel.</para>
    <para> </para>
    <para>If a class holds the instance of another class, then it is called composition.</para>
    <para> </para>
    <para>How aggregation and composition are different concepts?</para>
    <para> </para>
    <para>In OOPS, Aggregation and Composition are the types of association relations. A composition is a strong relationship. If the composite object is destroyed, then all its parts are destroyed. E.g. A Car has a Steering Wheel. If Car object is destroyed, then there is no meaning of Steering Wheel.</para>
    <para> </para>
    <para>In Aggregation, the relationship is weaker than Composition.</para>
    <para> </para>
    <para>E.g. A Library has students. If a Library is destroyed, Students still exist. So Library and Student are related by Aggregation. A Library has Books. If Library is destroyed, the Books are also destroyed. Books of a Library cannot exist without the Library. So Book and Library are related by Composition.</para>
    <para> </para>
    <para> </para>
    <para>Why there are no pointers in Java?</para>
    <para> </para>
    <para>In Java there are references instead of pointers. These references point to objects in memory. But there is no direct access to these memory locations. JVM is free to move the objects within VM memory.</para>
    <para> </para>
    <para>The absence of pointers helps Java in managing memory and garbage collection effectively. Also it provides developers with convenience of not getting worried about memory allocation and deallocation.</para>
    <para> </para>
    <para>If there are no pointers in Java, then why do we get</para>
    <para>NullPointerException?</para>
    <para> </para>
    <para>In Java, the pointer equivalent is Object reference. When we use a . it points to object reference.  So JVM uses pointers but programmers only see object references.</para>
    <para> </para>
    <para>In case an object reference points to null object, and we try to access a method or member variable on it, then we get NullPointerException.</para>
    <para>What is the purpose of ‘super’ keyword in java?</para>
    <para> </para>
    <para>‘super’ keyword is used in the methods or constructor of a child class. It refers to immediate parent class of an object.</para>
    <para> </para>
    <para>By using ‘super’ we can call a method of parent class from the method of a child class.</para>
    <para> </para>
    <para>We can also call the constructor of a parent class from the constructor of a child class by using ‘super’ keyword.</para>
    <para> </para>
    <para>Is it possible to use this() and super() both in same constructor?</para>
    <para> </para>
    <para>No, Java does not allow using both super() and this() in same constructor. As per Java specification, super() or this() must be the first statement in a constructor.</para>
    <para> </para>
    <para> What is the meaning of object cloning in Java?</para>
    <para> </para>
    <para>Object.clone() method is used for creating an exact copy of the object in Java. It acts like a copy constructor. It creates and returns a copy of the object, with the same class and with all the fields having same values as of the original object.</para>
    <para> </para>
    <para>One disadvantage of cloning is that the return type is an Object. It has to be explicitly cast to actual type.</para>
    <para> </para>
    <para> </para>
    <para> </para>
  </sect1>
  <sect1>
    <title>Static</title>
    <para> </para>
    <para>In Java, why do we use static variable?</para>
    <para> </para>
    <para>Whenever we want to have a common property for all objects of a class, we use a class level variable i.e. a static variable.</para>
    <para> </para>
    <para>This variable is loaded in memory only once at the time of class loading. So it saves memory, since it is not defined per object in Java.</para>
    <para> </para>
    <para>Why it is not a good practice to create static variables in Java?</para>
    <para> </para>
    <para>Static variables are common to all the objects of a class. If a new object is created, there is no need to test the value of static variable. Any code that uses static variable can be in any state. It can be within a new object or at a class level. So the scope of static variable is open ended in a Java class.</para>
    <para> </para>
    <para>If we want tighter control on scope, then variables should be created at the object creation level.</para>
    <para> </para>
    <para>Also defining static variables is not a good practice because they go against the principles of Object Oriented Programming.</para>
    <para> </para>
    <para>What is the purpose of static method in Java?</para>
    <para> </para>
    <para>Java provides the feature of static method to create behavior at the class level. The static method is common to all the objects of a class.  We do not need to create any object of a class to call a static method. So it provides convenience of not creating an object for calling it.</para>
    <para> </para>
    <para>Also a static method can access and modify static data members. This also helps in keeping the behavior as well as state at the class level.</para>
    <para> </para>
    <para>Why do we mark main method as static in Java?</para>
    <para> </para>
    <para>The main method in Java is marked as static, so that JVM can call it to start the program. If main method is not static, then which constructor will be called by Java process?</para>
    <para> </para>
    <para>As such it is a known as convention to mark main method static in Java. But if we remove the static, then there will be ambiguity. Java process may not know which method of a class to call to start the program.</para>
    <para> </para>
    <para>So this convention helps in Java process to identify the starting code for a program in class that is passed as an argument to java process.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>In what scenario do we use a static block?</para>
    <para> </para>
    <para>At times, there is a class that has static member variables. These variables need some complicated initialization. At this time static block helps as a tool to initialize complex static member variable initialization.</para>
    <para> </para>
    <para>The static block is executed even before the execution of main.</para>
    <para> </para>
    <para>Sometimes, we can also replace static block with a static method of class.</para>
    <para> </para>
    <para>Is it possible to execute a program without defining a main() method?</para>
    <para> </para>
    <para>No, with Java 7 onwards, you need a main() method to execute a program. In earlier versions of Java, there was a workaround available to use static blocks for execution. But now this gap has been closed.</para>
    <para> </para>
    <para>What happens when static modifier is not mentioned in the signature of main method?</para>
    <para> </para>
    <para>As per Java specification, main method has to be marked as static. It needs only one argument that is an array of String.</para>
    <para> </para>
    <para>A program can compile with a non-static method. But on execution it will give NoSuchMethodError.</para>
    <para> </para>
    <para>What is the difference between static method and instance method in Java?</para>
    <para> </para>
    <para>Often, there is a need to define a behavior for a class that is not dependent on member variables of an object. Such behavior is captured in a static method. If there is a behavior dependent upon the member variables of an object, then we do not mark it static, it remains as instance method.</para>
    <para> </para>
    <para>To call as static method, we do not need to create an object. We just call it with class name. But to call an instance method, we need to create/get an object first.</para>
    <para> </para>
    <para>Instance member variables cannot be accessed by a static method. But an instance method can call both instance variables and static variables.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>Method Overloading and Overriding</para>
    <para> </para>
    <para>40.    What is the other name of Method Overloading?</para>
    <para> </para>
    <para>Method Overloading is also known as Static Polymorphism.</para>
    <para> </para>
    <para> How will you implement method overloading in Java?</para>
    <para> </para>
    <para>In Java, a class can have multiple methods with same name but different arguments.  It is called Method Overloading. To implement method overloading we have to create two methods with same name in a class and do one/more of the following:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Different number of parameters</para>
      </listitem>
      <listitem>
        <para>Different data type of parameters</para>
      </listitem>
      <listitem>
        <para>Different sequence of data type of parameters</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>What kinds of argument variations are allowed in Method Overloading?</para>
    <para> </para>
    <para>Method Overloading allows two methods with same name to differ in:</para>
    <orderedlist>
      <listitem>
        <para>Number of parameters</para>
      </listitem>
      <listitem>
        <para>Data type of parameters</para>
      </listitem>
      <listitem>
        <para>Sequence of data type of parameters</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>Why it is not possible to do method overloading by changing return type of method in java?</para>
    <para> </para>
    <para>If we change the return type of overloaded methods then it will lead to ambiguous behavior. How will clients know which method will return what type. Due to this different return type are not allowed in overloaded methods.</para>
    <para> </para>
    <para>Is it allowed to overload main() method in Java?</para>
    <para> </para>
    <para>Yes, Java allows users to create many methods with same name ‘main’. But only public static void main(String[] args) method is used for execution.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>How do we implement method overriding in Java?</para>
    <para> </para>
    <para>To override a method, we just provide a new implementation of a method with same name in subclass. So there will be at least two implementations of the method with same name. One implementation is in parent class. And another implementation is in child class.</para>
    <para> </para>
    <para> </para>
    <para>Are we allowed to override a static method in Java?</para>
    <para> </para>
    <para>No. Java does not allow overriding a static method. If you create a static method with same name in subclass, then it is a new method, not an overridden method.</para>
    <para> </para>
    <para>Why Java does not allow overriding a static method?</para>
    <para> </para>
    <para>To override a method, you need an instance of a class. Static method is not associated with any instance of the class. So the concept of overriding does not apply here.</para>
    <para> </para>
    <para>Therefore, Java does not allow overriding a static method.</para>
    <para> </para>
    <para>48. Is it allowed to override an overloaded method?</para>
    <para> </para>
    <para>Yes. You can override an overloaded method in Java.</para>
    <para> </para>
    <para>What is the difference between method overloading and method overriding in Java?</para>
    <para> </para>
    <para>Differences between method overloading and overriding are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Method overloading is static polymorphism. Method overriding is runtime polymorphism.</para>
      </listitem>
      <listitem>
        <para>Method overloading occurs within the same class. Method overriding happens in two classes with hierarchy relationship.</para>
      </listitem>
      <listitem>
        <para>Parameters must be different in method overloading. Parameters must be same in method overriding.</para>
      </listitem>
      <listitem>
        <para>Method overloading is a compile time concept. Method overriding is a runtime concept.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para>50. Does Java allow virtual functions?</para>
    <para> </para>
    <para>Yes. All instance methods in Java are virtual functions by default. Only class methods and private instance methods are not virtual methods in Java.</para>
    <para> </para>
    <para> What is meant by covariant return type in Java?</para>
    <para> </para>
    <para>A covariant return type of a method is one that can be replaced by a "narrower" type when the method is overridden in a subclass.</para>
    <para> </para>
    <para>Let say class B is child of class A. There is a get() method in class A as well as class B. get() method of class A can return an instance of A, and get() method of class B return an instance of B.  Here class B overrides get() method, but the return type is different.</para>
    <para> </para>
    <para>Before Java 5, any method that overrides the method of parent class would have same return type.</para>
    <para> </para>
    <para>From Java 5 onwards, a child class can override a method of parent class and the child class method can return an object that is child of object return by parent class method.</para>
  </sect1>
  <sect1>
    <title>Polymorphism</title>
    <para> </para>
    <para>What is Runtime Polymorphism?</para>
    <para> </para>
    <para>Runtime Polymorphism or Dynamic Polymorphism is the polymorphism that exists at runtime. In case of method overriding it is not known which method will be called at runtime. Based on the type of object, JVM decides the exact method that should be called.</para>
    <para> </para>
    <para>So at compile time it is not known which method will be called at run time.</para>
    <para> </para>
    <para> </para>
    <para>    Is it possible to achieve Runtime Polymorphism by data members in Java?</para>
    <para> </para>
    <para>No. We need to create Runtime Polymorphism by implementing methods at two levels of inheritance in Java.</para>
    <para> </para>
    <para>Explain the difference between static and dynamic binding?</para>
    <para> </para>
    <para>In Static binding references are resolved at compile time. In Dynamic binding references are resolved at Run time.</para>
    <para> </para>
    <para>E.g.</para>
    <para>Person p = new Person();</para>
    <para>p.walk();  // Java compiler resolves this binding at compile time.</para>
    <para> </para>
    <para>public void walk(Object o){</para>
    <para>((Person) o).walk(); // this is dynamic binding. }</para>
    <para> </para>
  </sect1>
  <sect1>
    <title>Abstraction</title>
    <para> </para>
    <para>What is Abstraction in Object Oriented programming?</para>
    <para> </para>
    <para>Abstraction is the process of hiding certain implementation details of an object and showing only essential features of the object to outside world.</para>
    <para> </para>
    <para>It is different from Abstract class in Java.</para>
    <para> </para>
    <para>Abstraction process identifies commonalities and hides the complexity of implementation. It helps us in focusing on the interface that we share with the outside world.</para>
    <para> </para>
    <para>How is Abstraction different from Encapsulation?</para>
    <para> </para>
    <para>Abstraction happens at class level design. It results in hiding the implementation details. Encapsulation is also known as “Information Hiding”.  An example of encapsulation is marking the member variables private and providing getter and setter for these member variables.</para>
    <para> </para>
    <para>What is an abstract class in Java?</para>
    <para> </para>
    <para>An abstract class in Java has one or more abstract methods. An abstract method is just declared in the abstract class, but it is not implemented.</para>
    <para> </para>
    <para>An abstract class has to be extended in Java and its abstract methods have to be implemented by a child class. Also Java does not allow new instance of Abstract class.</para>
    <para> </para>
    <para>Is it allowed to mark a method abstract method without marking the class abstract?</para>
    <para> </para>
    <para>No. Java specification says that if there is at least one abstract method in a class, the class has to be marked abstract.</para>
    <para> </para>
    <para>Is it allowed to mark a method abstract as well as final?</para>
    <para> </para>
    <para>No. It will be contradictory statement to mark a method abstract as well as final.</para>
    <para> </para>
    <para>An abstract method has to be overridden by a child class. And a final method cannot be overridden.  Therefore a method can be either abstract or final in Java.</para>
    <para> </para>
    <para>60. Can we instantiate an abstract class in Java?</para>
    <para> </para>
    <para>No. We cannot create an instance of an abstract class in Java.</para>
    <para> </para>
    <para> What is an interface in Java?</para>
    <para> </para>
    <para>An Interface in Java is an abstract type blueprint of a class. It contains the methods that a class must implement. It is like a protocol.</para>
    <para> </para>
    <para>It has method signatures and constant declarations.</para>
    <para> </para>
    <para>Is it allowed to mark an interface method as static?</para>
    <para> </para>
    <para>Yes, from Java 8 onwards, we can define static and default methods in an interface. Prior to Java 8, it was not allowed.</para>
    <para> </para>
    <para>Why an Interface cannot be marked as final in Java?</para>
    <para> </para>
    <para>A final method cannot be overridden. But an interface method has to be implemented by another class. So the interface method cannot be marked as final.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>What is a marker interface?</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>There are interfaces that do not have any data member or methods.</para>
    <para>These interfaces are called Marker interface. E.g. Serializable, Cloneable, Remote etc.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>What can we use instead of Marker interface?</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>We can use annotations instead of Marker interface.</para>
    <para> </para>
    <para>How Annotations are better than Marker Interfaces?</para>
    <para> </para>
    <para>Annotations serve the purpose of conveying metadata about the class to its consumers without creating a separate type for it.</para>
    <para> </para>
    <para>Annotations are more powerful than a Marker interface. They allow programmers to pass more sophisticated information to classes that "consume" it.</para>
    <para> </para>
    <para>What is the difference between abstract class and interface in Java?</para>
    <para> </para>
    <para>Differences between Abstract class and Interface are as follows:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>An abstract class can have implemented methods with body (non-abstract methods). Interface has only abstract methods. From Java 8 onwards, interface can have static/default methods in implemented form.</para>
      </listitem>
      <listitem>
        <para>An abstract class can have instance member variables. An interface cannot have instance variables. It can only have constants.</para>
      </listitem>
      <listitem>
        <para>An abstract class can have a constructor. Interface cannot have constructor. It has to be implemented by another class.</para>
      </listitem>
      <listitem>
        <para>A class can extend only one abstract class. A class can implement more than one interface.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>Does Java allow us to use private and protected modifiers for variables in interfaces?</para>
    <para> </para>
    <para>No. All the variables in an interface are implicitly public.</para>
    <para> </para>
    <para>How can we cast to an object reference to an interface reference?</para>
    <para> </para>
    <para>An Object that implements an Interface can be cast to the same Interface. Since An Object implementing an Interface already provides implementation for the methods of that Interface, it is allowed to do so as per the rules of Inheritance.</para>
    <para> </para>
  </sect1>
  <sect1>
    <title>Final</title>
    <para> </para>
    <para>How can you change the value of a final variable in Java?</para>
    <para> </para>
    <para>Java does not allow changing the value of a final variable. Once the value is set, it cannot be changed.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> Can a class be marked final in Java?</para>
    <para> </para>
    <para>Yes a class can be marked final in Java. Once a class is marked final, it cannot be extended.</para>
    <para>How can we create a final method in Java?</para>
    <para> </para>
    <para>To mark a method, add modifier final to that method. A final method can not be overridden by a child class.</para>
    <para>How can we prohibit inheritance in Java?</para>
    <para> </para>
    <para>If you mark a class final, it cannot be extended. This will prohibit the inheritance of that class in Java.</para>
    <para>74. Why Integer class in final in Java?</para>
    <para> </para>
    <para>Integer class is a wrapper for int. If it is not marked final, then any other class can extend it and modify the behavior of Integer operations. To avoid this Integer wrapper class is marked as final.</para>
    <para> </para>
    <para>What is a blank final variable in Java?</para>
    <para> </para>
    <para>When we declare a final variable without giving any initial value, then it is called blank final variable.</para>
    <para> </para>
    <para>How can we initialize a blank final variable?</para>
    <para> </para>
    <para>A blank final instance variable can be initialized in a constructor.</para>
    <para> </para>
    <para>A blank final static variable can be initialized in the static block of class.</para>
    <para> </para>
    <para>Is it allowed to declare main method as final?</para>
    <para> </para>
    <para>Yes, we can mark the main method as final.</para>
    <para> </para>
    <para> </para>
  </sect1>
  <sect1>
    <title>Package</title>
    <para> </para>
    <para>What is the purpose of package in Java?</para>
    <para> </para>
    <para>A package is used to encapsulate a group of classes, interfaces and sub-packages. Often, it is a hierarchical structure of storing information. It is easier to organize the related classes and subpackages in this manner.</para>
    <para> </para>
    <para>A Package also provides access protection for classes and interfaces. A package also helps in removing naming collision.</para>
    <para> </para>
    <para>79.    What is java.lang package?</para>
    <para> </para>
    <para>In Java, java.lang package contains the classes that are fundamental to the design of Java programming language. The most important class in this package is Object class.</para>
    <para> </para>
    <para>It also contains wrapper classes like- Integer, Boolean, Character etc. It provides Math class for mathematical operations.</para>
    <para> </para>
    <para>Which is the most important class in Java?</para>
    <para> </para>
    <para>It is an open-ended question with many answers. In my view, Object class is the most important class of Java programming language. It is the root of all the classes in Java. It provides some very important and fundamental methods.</para>
    <para> </para>
    <para>81. Is it mandatory to import java.lang package every time?</para>
    <para> </para>
    <para>No. By default, JVM loads it internally.</para>
    <para> </para>
    <para>Can you import same package or class twice in your class?</para>
    <para> </para>
    <para>If we import same package multiple times in a class, compiler includes it only once. So neither JVM nor Compiler gives any error/warning on including a package multiple times.</para>
    <para> </para>
    <para>If you have two classes with same name, then you may get name collision on importing the class erroneously.</para>
    <para> </para>
    <para>JVM internally loads the class only one time.</para>
    <para> </para>
    <para>What is a static import in Java?</para>
    <para> </para>
    <para>Static import is similar to normal import declaration. Normal import allows us to import classes from packages without using package qualifier. Static import allows us to import static members from a class without using class qualifier.</para>
    <para> </para>
    <para>What is the difference between import static com.test.Fooclass and import com.test.Fooclass?</para>
    <para> </para>
    <para>First import is a static import and the second import is normal import of a class. First import allows us to import static members of class.</para>
    <para> </para>
    <para> </para>
    <para> </para>
  </sect1>
  <sect1>
    <title>Internationalization</title>
    <para> </para>
    <para>85. What is Locale in Java?</para>
    <para> </para>
    <para>A Locale object represents a specific geographical, political, or cultural region. It is used to locale-sensitive operations in Java.</para>
    <para> </para>
    <para>It helps is following the local conventions of a country, native or region. These conventions can be for formatting the dates, money, numbers etc.</para>
    <para> </para>
    <para>86.    How will you use a specific Locale in Java?</para>
    <para> </para>
    <para>To use a specific Locale, we need to load that Locale. We can use ResourceBundle.getBundle("Locale.UK") method to load a Locale.</para>
    <para> </para>
  </sect1>
  <sect1>
    <title>Serialization</title>
    <para> </para>
    <para>87.    What is the serialization?</para>
    <para> </para>
    <para>Serialization is a process converting an object into a byte array. This byte array represents the class, version and internal state of the object. JVM can use this byte array to transmit/read the object over a network.</para>
    <para> </para>
    <para>What is the purpose of serialization?</para>
    <para> </para>
    <para>Some of the uses of serialization are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Communication: It is used for transmitting an object over network between two machines.</para>
      </listitem>
      <listitem>
        <para>Persistence: We can store the object’s state in a database and retrieve it from database later on.</para>
      </listitem>
      <listitem>
        <para>Caching: Serialization can be used for caching to improve performance. We may need 10 minutes to build an object, but it may take just 10 seconds to de-serialize the object.</para>
      </listitem>
      <listitem>
        <para>Cross JVM Synchronization: It can be used in same way across multiple JVM that follow different architecture.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>89.    What is Deserialization?</para>
    <para> </para>
    <para>Deserialization is the process of reconstructing the object from the serialized state. It is the reverse process of serialization.</para>
    <para> </para>
    <para>What is Serialization and Deserialization conceptually?</para>
    <para> </para>
    <para>Serialization is to convert Object data into a stream of bytes</para>
    <para> </para>
    <para>Deserialization is to convert a stream of bytes back into a copy of the original object.</para>
    <para> </para>
    <para> Why do we mark a data member transient?</para>
    <para> </para>
    <para>Member variables of an object are marked transient to indicate that they should not be serialized.</para>
    <para> </para>
    <para>During serialization process the transient variables are not considered part of the persistent state of an object.</para>
    <para> </para>
    <para>Is it allowed to mark a method as transient?</para>
    <para> </para>
    <para>No, Java does not allow marking a method as transient. The transient keyword is valid only for member variables.</para>
    <para> </para>
    <para>How does marking a field as transient makes it possible to serialize an object?</para>
    <para> </para>
    <para>Let say we have a class ABC that implements Serializable interface, but it contains a member variable object of class XYZ that does not implement Serializable interface. Due to this it is not possible to Serialize the class ABC.</para>
    <para> </para>
    <para>To solve this issue, we can mark the member variable XYZ as Transient in class ABC. This will allow us to serialize the class</para>
    <para>ABC.</para>
    <para> </para>
    <para>What is Externalizable interface in Java?</para>
    <para> </para>
    <para>Externalizable interface extends Serializable interface in Java. It is used for giving the Class control over saving and restoring the contents of its instances.</para>
    <para> </para>
    <para>A class implements methods writeExternal() and readExternal() to store and restore the object.</para>
    <para> </para>
    <para>What is the difference between Serializable and Externalizable interface?</para>
    <para> </para>
    <para>Serializable is a marker interface but Externalizable is not a marker interface.</para>
    <para> </para>
    <para>When we implement Serializable interface, the class is serialized automatically by default. We can override writeObject() and readObject()methods to control more complex object Serialization process.</para>
    <para> </para>
    <para>In case of Externalizable, we use readExternal() and writeExternal() methods to give control to class for class's serialization process.</para>
    <para> </para>
    <para>Serializable interface is based on recursive algorithm.</para>
    <para> </para>
    <para>Serializable gives you two options. One option is to provide custom way of serialization, the other default way. In Externalizable, you have to always implement readExternal() and writeExternal() methods.</para>
    <para> </para>
    <para>A public no-arg constructor is needed while using Externalizable interface.</para>
    <para> </para>
    <para>In Serialization, we need to define serialVersionUID. If it is not explicitly defined it will be generated automatically based on all the fields, methods of the class.</para>
    <para> </para>
  </sect1>
  <sect1>
    <title>Reflection</title>
    <para> </para>
    <para>What is Reflection in Java?</para>
    <para> </para>
    <para>Reflection is Java language's ability to inspect and dynamically call classes, methods, attributes etc. at Runtime. It helps in examining or modifying the Runtime behavior of a class at Runtime.</para>
    <para> </para>
    <para> </para>
    <para>What are the uses of Reflection in Java?</para>
    <para> </para>
    <para>Reflection is often used in Testing, Debugging and in Integrated Development Environment (IDE).</para>
    <para> </para>
    <para>Reflection allows you to write programs that do not have to "know" everything at compile time. It makes programs more dynamic, since they can be tied together at runtime.</para>
    <para> </para>
    <para>Many modern frameworks like Spring etc. use Reflection. Some modern languages like Python etc. also use Reflection.</para>
    <para> </para>
    <para>JAVA API for XML Parsing (JAXP) also uses Reflection.</para>
    <para> </para>
    <para> </para>
    <para>How can we access private method of a class from outside the class?</para>
    <para> </para>
    <para>We can use Reflection to access private method of a class from outside the class. IN Java, we use getDeclaredMethod() to get instance of a private method. Then we mark this method accessible and finally invoke it.</para>
    <para> </para>
    <para>In following sample code, we are accessing private method message() of class Foo by Reflection.</para>
    <para> </para>
    <para>FileName: Foo.java public class Foo {   private void message(){System.out.println("hello java"); } </para>
    <para>} </para>
    <para> </para>
    <para>FileName: FooMethodCall.java import java.lang.reflect.Method; public class FooMethodCall{ public static void main(String[] args)throws Exception{ </para>
    <para> </para>
    <para>    Class c = Class.forName("Foo"); </para>
    <para>    Object o= c.newInstance(); </para>
    <para>    Method m =c.getDeclaredMethod("message", null);     m.setAccessible(true); </para>
    <para>    m.invoke(o, null); </para>
    <para>} </para>
    <para>} </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>How can we create an Object dynamically at Runtime in Java?</para>
    <para> </para>
    <para>We can use Reflection to create an Object dynamically at Runtime in Java. We can use Class.newInstance() or</para>
    <para>Constructor.newInstance() methods for creating such Objects.</para>
    <para> </para>
    <para> </para>
  </sect1>
  <sect1>
    <title>Garbage Collection</title>
    <para> </para>
    <para> What is Garbage Collection in Java?</para>
    <para> </para>
    <para>Java has an internal mechanism called Garbage collection to reclaim the memory of unused projects at run time.</para>
    <para> </para>
    <para>Garbage collection is also known as automatic memory management.</para>
    <para> </para>
    <para>  Why Java provides Garbage Collector?</para>
    <para> </para>
    <para>In Java, there are no pointers. Memory management and allocation is done by JVM. Since memory allocation is automated, after some time JVM may go low on memory. At that time, JVM has to free memory from unused objects. To help with the process of reclaiming memory, Java provides an automated process called Garbage Collector.</para>
    <para> </para>
    <para> What is the purpose of gc() in Java?</para>
    <para> </para>
    <para>Java provides two methods System.gc() and Runtime.gc() to request the JVM to run the garbage collection. By using these methods, programmers can explicitly send request for Garbage Collection. But JVM process can reject this request and wait for some time before running the GC.</para>
    <para> </para>
    <para>How does Garbage Collection work in Java?</para>
    <para> </para>
    <para>Java has an automated process called Garbage Collector for Memory Management. It is a daemon in JVM that monitors the memory usage and performs memory cleanup. Once JVM is low on memory, GC process finds the unused objects that are not referenced by other objects. These unused objects are cleaned up by Garbage Collector daemon in JVM.</para>
    <para> </para>
    <para>               When does an object become eligible for Garbage Collection in Java?</para>
    <para> </para>
    <para>An object can be Garbage Collected by JVM, if it is not reachable. There are two cases for deciding eligibility of objects for Garbage Collection:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>An Object/instance that cannot be reached by a live thread.</para>
      </listitem>
      <listitem>
        <para>A set of circularly referenced instances that cannot be reached by any other instance outside that set.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>Why do we use finalize() method in Java?</para>
    <para> </para>
    <para>Java provides finalize() method to perform any cleanup before Garbage Collection. This method is in Object class, and it is invoked by JVM internally. Developers are free to implement this method for any custom cleanup in case of Garbage Collection.</para>
    <para> </para>
    <para>If an Object is not Garbage Collected, then this method may not be called.</para>
    <para> </para>
    <para>This method is never invoked more than once by JVM.</para>
    <para> </para>
    <para>What are the different types of References in Java?</para>
    <para> </para>
    <para>In Java, there are four types of references:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Strong Reference</para>
      </listitem>
      <listitem>
        <para>Soft Reference</para>
      </listitem>
      <listitem>
        <para>Weak Reference</para>
      </listitem>
      <listitem>
        <para>Phantom Reference</para>
      </listitem>
    </orderedlist>
    <para>How can we reference an unreferenced object again?</para>
    <para> </para>
    <para>We can provide implementation in finalize() method to reference and unreferenced object. For an unreferenced object, finalize() method is called at the time of Garbage Collection. At this time, Object can pass its reference ‘this’ to finalize() method and revive itself.</para>
    <para> </para>
    <para>What kind of process is the Garbage collector thread?</para>
    <para> </para>
    <para>Garbage Collection is a Daemon process in JVM. It is an internal process that keep checking Memory usage and cleans up the memory.</para>
    <para> </para>
    <para>What is the purpose of the Runtime class?</para>
    <para> </para>
    <para>The purpose of the Runtime class is to provide access to the Java</para>
    <para>Runtime system. This class provides certain important methods like:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Runtime.freeMemory() – This method returns the value of free memory in JVM</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Runtime.maxMemory() - This method returns the value of maximum memory that JVM can use.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Runtime.gc() – This method can invoke garbage collection.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>  How can we invoke an external process in Java?</para>
    <para> </para>
    <para>Java provides the method Runtime.getRuntime().exec() to invoke an external process from JVM.</para>
    <para> </para>
    <para>   What are the uses of Runtime class?</para>
    <para> </para>
    <para>Runtime class in Java provides following benefits:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>It allows to read data via key board</para>
      </listitem>
      <listitem>
        <para>It can use system properties and environment variables</para>
      </listitem>
      <listitem>
        <para>It helps in running non-java programs from within a java application.</para>
      </listitem>
    </orderedlist>
  </sect1>
  <sect1>
    <title>Inner Classes</title>
    <para> </para>
    <para>112. What is a Nested class?</para>
    <para> </para>
    <para>In Java, a Nested class is a class declared inside another class. We can have more than one class declared inside a file.</para>
    <para> </para>
    <para>  How many types of Nested classes are in Java?</para>
    <para> </para>
    <para>Java provides four types of Nested classes:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Member inner class</para>
      </listitem>
      <listitem>
        <para>Local inner class</para>
      </listitem>
      <listitem>
        <para>Anonymous inner class</para>
      </listitem>
      <listitem>
        <para>Static nested class</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para>114. Why do we use Nested Classes?</para>
    <para> </para>
    <para>There are following reasons for using nested classes:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Logical Grouping: We can logically group classes in one place. If one class is useful to only one other class, then we put smaller class within the larger class and keep them in one file. This kind of nesting "helper classes" in a toplevel class makes the package more streamlined.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Encapsulation: Nested classes increase encapsulation. Let say there are two top-level classes, Foo and Bar. Bar needs access to private members of Foo. We can hide class Bar within class Foo. In this way, private members of Foo can be accessed by class Bar. So class Foo remains encapsulated. Also, class Bar remains hidden from the outside world.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Code Clarity: Nested classed make the code more readable and well organized. Only Top-level classes are exposed. The helper classes are kept hidden and closer the code where it is used by a Top-level class.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> What is the difference between a</para>
    <para>Nested class and an Inner class in Java?</para>
    <para> </para>
    <para>An Inner class in Java is non-static class. It is a type of Nested class that is defined in another class but not qualified with a Static modifier. A Nested class is also a class can be Static Nested class or a non-Static Inner class.</para>
    <para> </para>
    <para>An Inner class has access to other members of the enclosing class, even if they are declared private. A Static Nested class can not access the other members of the enclosing class.</para>
    <para> </para>
    <para>  What is a Nested interface?</para>
    <para> </para>
    <para>A Nested interface is declared inside another interface or a toplevel class. By default it is static.</para>
    <para> </para>
    <para>A Nested interface is also known as Static interface.</para>
    <para> </para>
    <para>  How can we access the non-final local variable, inside a Local Inner class?</para>
    <para> </para>
    <para>Java allows a Local Inner class to access only Constant local members. So we have to make the non-final local variable as final constant to access it inside a Local Inner class.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>Can an Interface be defined in a Class?</para>
    <para> </para>
    <para>Yes, we can define a Static Nested interface within a class. Only the enclosing class can access it.</para>
    <para> </para>
    <para>119. Do we have to explicitly mark a Nested Interface public static?</para>
    <para> </para>
    <para>A Nested Interface is implicitly public static. So the modifiers public and static are redundant in declaration.</para>
    <para>120. Why do we use Static Nested interface in Java?</para>
    <para> </para>
    <para>Only the enclosing class can access a Static Nested interface. Consider following code in which interface Xyz is enclosed in class Abc.</para>
    <para> </para>
    <para>public class Abc {</para>
    <para> </para>
    <para>    public interface Xyz {         void callback();</para>
    <para>    }</para>
    <para> </para>
    <para>    public static void registerCallback(Xyz xyz) {...}</para>
    <para>}</para>
    <para> </para>
    <para>// Client Code</para>
    <para>Abc.registerCallback(new Abc.Xyz() {</para>
    <para>    public void callback() {...}</para>
    <para>});</para>
    <para> </para>
    <para>Any code that cannot access Abc can not access interface Xyz also.</para>
    <para> </para>
    <para>So the purpose of declaring an Inner interface is to restrict its access from outside world.</para>
    <para> </para>
    <para> </para>
    <para>String</para>
    <para> </para>
    <para>What is the meaning of Immutable in the context of String class in Java?</para>
    <para> </para>
    <para>An Immutable object cannot be modified or changed in Java. String is an Immutable class in Java.</para>
    <para> </para>
    <para>Once a String object is created, it cannot be changed. When we assign the String to a new value, a new object is created.</para>
    <para> </para>
    <para> Why a String object is considered immutable in java?</para>
    <para> </para>
    <para>Java language uses String for a variety of purposes. For this it has marked String Immutable.</para>
    <para> </para>
    <para>There is a concept of String literal in Java.</para>
    <para> </para>
    <para>Let say there are 2 String variables A and B that reference to a String object “TestData”. All these variables refer to same String literal. If one reference variable A changes the value of the String literal from “TestData” to “RealData”, then it will affect the other variable as well. Due to which String is considered Immutable. In this case, if one variable A changes the value to “RealData”, then a new String literal with “RealData” is created and A will point to new String literal. While B will keep pointing to “TestData”</para>
    <para> </para>
    <para> </para>
    <para>How many objects does following code create?</para>
    <para> </para>
    <para>Code:</para>
    <para>String s1="HelloWorld"; </para>
    <para>String s2=" HelloWorld "; </para>
    <para>String s3=" HelloWorld "; </para>
    <para> </para>
    <para> </para>
    <para>The above code creates only one object. Since there is only one String Literal “HelloWorld” created, all the references point to same object.</para>
    <para> </para>
    <para>               How many ways are there in Java to create a String object?</para>
    <para> </para>
    <para>Java provides two ways to create a String object. One is by using String Literal, the other is by using new operator.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>How many objects does following code create?</para>
    <para> </para>
    <para>Code:</para>
    <para>String s = new String("HelloWorld"); </para>
    <para> </para>
    <para>The above code creates two objects. One object is created in String constant pool and the other is created on the heap in non-pool area.</para>
    <para> </para>
    <para> </para>
    <para>What is String interning?</para>
    <para> </para>
    <para>String interning refers to the concept of using only one copy of a distinct String value that is Immutable.</para>
    <para> </para>
    <para>It provides the advantage of making String processing efficient in Time as well as Space complexity. But it introduces extra time in creation of String.</para>
    <para> </para>
    <para>Why Java uses String literal concept?</para>
    <para> </para>
    <para>Java uses String literal concept to make Java more efficient in memory. If same String already exists in String constant pool, it can be reused. This saves memory usage.</para>
    <para> </para>
    <para> </para>
    <para>               What is the basic difference</para>
    <para>between a String and StringBuffer object?</para>
    <para> </para>
    <para>String is an immutable object. Its value cannot change after creation. StringBuffer is a mutable object. We can keep appending or modifying the contents of a StringBuffer in Java.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>How will you create an immutable class in Java?</para>
    <para> </para>
    <para>In Java, we can declare a class final to make it immutable. There are following detailed steps to make it Immutable:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Add final modifier to class to prevent it from getting extended</para>
      </listitem>
      <listitem>
        <para>Add private modifier to all the fields to prevent direct access</para>
      </listitem>
      <listitem>
        <para>Do not provide any setter methods for member variables</para>
      </listitem>
      <listitem>
        <para>Add final modifier to all the mutable fields to assign value only once</para>
      </listitem>
      <listitem>
        <para>Use Deep Copy to initialize all the fields by a constructor</para>
      </listitem>
      <listitem>
        <para>In clone method, return a copy of object instead of the actual object reference</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> What is the use of toString() method in java ?</para>
    <para> </para>
    <para>In Java, Object class has toString() method. This method can be used to return the String representation of an Object. When we print an object, Java implicitly calls toString() method.</para>
    <para> </para>
    <para>Java provides a default implementation for toString() method. But we can override this method to return the format that we want to print.</para>
    <para> </para>
    <para>  Arrange the three classes String, StringBuffer and StringBuilder in the order of efficiency for String processing operations?</para>
    <para> </para>
    <para>StringBuilder is the most efficient class. It does not have the overhead of Synchronization. StringBuffer is a Synchronized class. It has better performance than String but it is slower than StringBuilder. String is the slowest for any String processing operations, since it is leads to creation of new String literal with each modification.</para>
    <para> </para>
    <para>So the decreasing order of efficiency is: StringBuilder, StringBuffer, String</para>
    <para> </para>
  </sect1>
  <sect1>
    <title>Exception Handling</title>
    <para> </para>
    <para> What is Exception Handling in Java?</para>
    <para> </para>
    <para>Java provides Exception Handling mechanism to handle Runtime errors that occur in JVM. There are checked exceptions in a program that we expect to occur in certain situations.</para>
    <para> </para>
    <para>Exception handling mechanism catches these checked exceptions and takes relevant actions.</para>
    <para> </para>
    <para>133.In Java, what are the differences between a Checked and Unchecked?</para>
    <para> </para>
    <para>Checked Exceptions extend Throwable class, but they do not extend RuntimeException or Error classes. UncheckedException extend RuntimeException class.</para>
    <para> </para>
    <para>Checked Exceptions are checked at compile time in Java. Unchecked Exceptions happen at Runtime, so they are not checked at compile time.</para>
    <para> </para>
    <para>IOException, SQLException etc. are examples of Checked Exceptions. NullPointerException, ArithmeticException etc. are examples of Unchecked Exceptions.</para>
    <para> </para>
    <para>               What is the base class for</para>
    <para>Error and Exception classes in Java?</para>
    <para> </para>
    <para>Error as well as Exception class is derived from Throwable class in Java.</para>
    <para> </para>
    <para> </para>
    <para>135.What is a finally block in Java?</para>
    <para> </para>
    <para>Java provides a finally block with a try block. This is an optional block. But finally block is always executed after the execution of try block.</para>
    <para> </para>
    <para>What is the use of finally block in Java?</para>
    <para> </para>
    <para>As per Java specification, a finally block is always executed, whether an error occurs or not, whether an exception is handled or not. It helps in doing the cleanup like- Rollback Transaction, Close Connection, Close a file etc.</para>
    <para> </para>
    <para>Can we create a finally block without creating a catch block?</para>
    <para> </para>
    <para>Yes. A finally block can follow a try block or catch block. So we can defined a finally block just after a try block.</para>
    <para> </para>
    <para>Do we have to always put a catch block after a try block?</para>
    <para> </para>
    <para>Java does not enforce the rule to put a catch block after try block. We can write catch block or finally block after a try block.</para>
    <para> </para>
    <para>Any exception that we want to catch is mentioned in catch block.</para>
    <para> </para>
    <para> </para>
    <para>In what scenarios, a finally block will not be executed?</para>
    <para> </para>
    <para>There are two main scenarios in which finally block is not executed:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Program exits by calling system.exit() call.</para>
      </listitem>
      <listitem>
        <para>A fatal error causes JVM to crash.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>               Can we re-throw an Exception in Java?</para>
    <para> </para>
    <para>Yes, Java allows to re-throw an Exception.</para>
    <para> </para>
    <para> </para>
    <para>What is the difference between throw and throws in Java?</para>
    <para> </para>
    <para>Java provides throw keyword to throw an exception from a method or a static block. Java provides throws keyword to mention the probable exception thrown by a method in its declaration.</para>
    <para> </para>
    <para>We use throw to explicitly throw an exception. We used             throws to declare an exception in method definition.</para>
    <para> </para>
    <para>We cannot propagate checked exceptions with throw only. But checked exceptions can be propagated with throws keyword.</para>
    <para> </para>
    <para>A throw call is followed by an instance. Class or Exception follows a throws keyword.</para>
    <para> </para>
    <para>Call to throw occurs within a method. throws is just used with method signature.</para>
    <para> </para>
    <para>We can throw only one exception at a time. But we can mention as many exceptions in throws clause.</para>
    <para> </para>
    <para> </para>
    <para>               What is the concept of</para>
    <para>Exception Propagation?</para>
    <para> </para>
    <para>In Exception Propagation, uncaught exceptions are propagated in the call stack until stack becomes empty. This propagation is called Exception Propagation.</para>
    <para> </para>
    <para> </para>
    <para>Let say an exception propagates from one method to another method. A() calls B(), which calls C(), which calls D(). And if D() throws an exception, the exception will propagate from D to C to B to A, unless one of the methods catches the exception.</para>
    <para> </para>
    <para> </para>
    <para>               When we override a method in a Child class, can we throw an additional Exception that is not thrown by the Parent class method?</para>
    <para> </para>
    <para>Yes, Java allows us to throw additional Exception in a child class, but the additional exception should be an unchecked exception (RuntimeException).</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
  </sect1>
  <sect1>
    <title>Java Collection</title>
    <para> </para>
    <para>              What is the difference between</para>
    <para>Collection and Collections Framework in Java?</para>
    <para> </para>
    <para>In Java, a Collection is an object that contains multiple elements of same type in a single unit. These multiple elements can be accessed through one Collection object.</para>
    <para> </para>
    <para>In Java Collections Framework is a library that provides common architecture for creating, updating and accessing different types of collections. In Collections framework there are common methods that are frequently used by developers for working on a Collection object.</para>
    <para> </para>
    <para> </para>
    <para>What are the main benefits of Collections Framework in Java?</para>
    <para> </para>
    <para>Main benefits of Collections Framework in Java are as follows:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Reusability: Java Collections Framework provides common classes and utility methods than can be used with different types of collections. This promotes the reusability of the code. A developer does not have to re-invent the wheel by writing the same method again.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Quality: Using Java Collection Framework improves the program quality, since the code is already tested and used by thousands of developers.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Speed: Most of programmers report that their development speed increased since they can focus on core logic and use the generic collections provided by Java framework.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Maintenance: Since most of the Java Collections framework code is open source and API documents is widely available, it is easy to maintain the code written with the help of Java Collections framework. One developer can easily pick the code of previous developer.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>What is the root interface of Collection hierarchy in Java?</para>
    <para> </para>
    <para>The root interface of Collection hierarchy in Java is Collection interface.</para>
    <para> </para>
    <para>But the Collection interface extends Iterable interface. Due to this some people consider Iterable interface as the root interface.</para>
    <para> </para>
    <para>Iterable interface is present in java.lang package but Collection interface is present in java.util package. Oracle Java API docs mention that Collection interface is a member of the Java Collections framework. </para>
    <para> </para>
    <para>Whereas, Iterable interface is not stated as a part of Java Collections framework in Java docs.</para>
    <para> </para>
    <para>Due to this Collection interface is the root of Collections Framework.</para>
    <para> </para>
    <para> </para>
    <para>What are the main differences between Collection and Collections?</para>
    <para> </para>
    <para>Main differences between Collection and Collections are as follows:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Collection is an interface in Java. But Collections is a class in Java.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Collection is a base interface. Collections is a utility class in Java.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Collection defines methods that are used for data structures that contain the objects. Collections defines the methods that are used for operations like access, find etc. on a Collection.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>              What are the Thread-safe classes in Java Collections framework?</para>
    <para> </para>
    <para>The Thread-safe classes in Java Collections framework are:</para>
    <para> </para>
    <para>Stack</para>
    <para>Properties</para>
    <para>Vector</para>
    <para>Hashtable</para>
    <para>BlockingQueue</para>
    <para>ConcurrentMap</para>
    <para>ConcurrentNavigableMap</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>               How will you efficiently</para>
    <para>remove elements while iterating a Collection?</para>
    <para> </para>
    <para>The right way to remove elements from a collection while iterating is by using ListIterator.remove() method.</para>
    <para> </para>
    <para>E.g.</para>
    <para> </para>
    <para>ListIterator&lt;Integer&gt; iter = myList.iterator(); while(iter.hasNext()) { itr.remove();</para>
    <para>}</para>
    <para> </para>
    <para>Some developers use following code to remove an element which is incorrect:</para>
    <para> </para>
    <para>Iterator&lt;Integer&gt; iter = myList.iterator(); while(iter.hasNext()) { itr.remove();</para>
    <para>}</para>
    <para> </para>
    <para>By doing so we get ConcurrentModificationException.</para>
    <para> </para>
    <para>An iterator is first created to traverse the list. But at the same time the list is changed by remove() method.</para>
    <para> </para>
    <para>In Java, it is not allowed for a thread to modify a collection while another thread is iterating it. ListIterator provides the capability of removing an object during traversal.</para>
    <para> </para>
    <para>How will you convert a List into an array of integers like- int[]?</para>
    <para> </para>
    <para>We can use ArrayUtils class in Apache Commons Lang library.</para>
    <para> </para>
    <para>Sample code is: int[]intArray         =         ArrayUtils.toPrimitive(myList.toArray(new</para>
    <para>Integer[0]));</para>
    <para> </para>
    <para> </para>
    <para>If we use List.toArray(), it will convert List to Integer[].</para>
    <para> </para>
    <para>Another option is:</para>
    <para> </para>
    <para>int[] intArray = new int[myList.size()]; for (int i=0; i &lt; myList.size(); i++) {</para>
    <para>  intArray [i] = myList.get(i);</para>
    <para>}</para>
    <para> </para>
    <para>How will you convert an array of primitive integers int[] to a List collection?</para>
    <para> </para>
    <para>We can use ArrayUtils in Apache Commons Lang library for this purpose.</para>
    <para> </para>
    <para>Sample code is:</para>
    <para> </para>
    <para>List intList = Arrays.asList(ArrayUtils.toObject(intArray));</para>
    <para> </para>
    <para>The other option would be to use a for loop and explicitly adding integers to a List.</para>
    <para> </para>
    <para>Sample code is:</para>
    <para> </para>
    <para>int[]intArray = {10,20,30};</para>
    <para>List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();</para>
    <para>for (int i: intArray) {</para>
    <para>  intList.add(i);</para>
    <para>}</para>
    <para> </para>
    <para>How will you run a filter on a Collection?</para>
    <para> </para>
    <para>We can use CollectionUtils of Apache for this purpose. We will have to create a Predicate that will define the condition for our filter. Then we can apply this Predicate in filter() method.</para>
    <para> </para>
    <para>Sample code is:</para>
    <para> </para>
    <para>In this example we filter any names that are less than 5 characters long.</para>
    <para> </para>
    <para>List&lt;String&gt; namesList = asList( "Red", "Blue", "Green" );</para>
    <para> </para>
    <para>List&lt;String&gt; shortNamesList = new ArrayList&lt;String&gt;(); shortNamesList.addAll( namesList );</para>
    <para> </para>
    <para>     CollectionUtils.filter( shortNamesList, new Predicate(){          public boolean evaluate( Object input ) {</para>
    <para>            return ((String) input).length() &lt; 5;</para>
    <para>         }</para>
    <para>      } );</para>
    <para> </para>
    <para> </para>
    <para>We can also use Google Guava library for this.</para>
    <para> </para>
    <para>In Java 8, we can use Predicate to filter a Collection through Stream.</para>
    <para> </para>
    <para>How will you convert a List to a Set?</para>
    <para> </para>
    <para>There are two ways to convert a List to a Set in Java.</para>
    <para> </para>
    <para>Option 1: Use HashSet</para>
    <para> </para>
    <para>Set&lt;Integer&gt; mySet = new HashSet&lt;Integer&gt;(myList);</para>
    <para> </para>
    <para>In this case we put a list into a HashSet. Internally hashCode() method is used to identify duplicate elements.</para>
    <para> </para>
    <para>Option 2: Use TreeSet</para>
    <para>In this case we use our own comparator to find duplicate objects.</para>
    <para> </para>
    <para>Set&lt;Integer&gt; mySet = new TreeSet&lt;Integer&gt;(myComparator); mySet.addAll(myList);</para>
    <para> </para>
    <para>               How will you remove duplicate elements from an ArrayList?</para>
    <para> </para>
    <para>The trick in this question is to use a collection that does not allow duplicate elements. So we use a Set for this purpose.</para>
    <para> </para>
    <para>Option 1: Use Set</para>
    <para>If ordering of elements is not important then we just put the elements of ArrayList in a HashSet and then add them back to the ArrayList.</para>
    <para> </para>
    <para>Sample Code is: </para>
    <para>ArrayList  myList = // ArrayList with duplicate elements Set&lt;Integer&gt; mySet = new HashSet&lt;Integer&gt;(myList); myList.clear();</para>
    <para>myList.addAll(mySet);</para>
    <para> </para>
    <para>Option 2: Use LinkedHashSet</para>
    <para>If ordering of elements is important then we put the elements of ArrayList in a LinkedHashSet and then add them back to the ArrayList.</para>
    <para> </para>
    <para>Sample Code is: </para>
    <para>ArrayList  myList = // ArrayList with duplicate elements Set&lt;Integer&gt; mySet = new LinkedHashSet&lt;Integer&gt;(myList); myList.clear();</para>
    <para>myList.addAll(mySet);</para>
    <para> </para>
    <para>How can you maintain a Collection with elements in Sorted order?</para>
    <para> </para>
    <para>In Java, there are many ways to maintain a Collection with elements in sorted order.</para>
    <para> </para>
    <para>Some collections like TreeSet store elements in the natural ordering. In case of natural ordering we have to implement Comparable interface for comparing the elements.</para>
    <para> </para>
    <para>We can also maintain custom ordering by providing a custom Comparator to a Collection.</para>
    <para> </para>
    <para>Another option is to use the utility method Collections.sort() to  sort a List. This sorting gives nlog(n) order of performance. But if we have to use this method multiple times then it will be costly on performance.</para>
    <para> </para>
    <para>Another option is to use a PriorityQueue that provides an ordered queue. The main difference between PriorityQueue and</para>
    <para>Collections.sort() is that PriorityQueue maintains a queue in Order all the time, but we can only retrieve head element from queue. We cannot access the elements of PriorityQueue in Random order.</para>
    <para> </para>
    <para>We can use TreeSet to maintain sorted order of elements in collection if there are no duplicate elements in collection.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>What are the differences between the two data structures: a Vector and an ArrayList?</para>
    <para> </para>
    <para>An ArrayList is a newer class than a Vector. A Vector is considered a legacy class in Java. The differences are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Synchronization: Vector is synchronized, but the ArrayList is not synchronized. So an ArrayList has faster operations than a Vector.</para>
      </listitem>
      <listitem>
        <para>Data Growth: Internally both an ArrayList and Vector use an array to store data. When an ArrayList is almost full it increases its size by 50% of the array size. Whereas a</para>
      </listitem>
    </orderedlist>
    <para>Vector increases it by doubling the underlying array size.</para>
    <para> </para>
    <para> </para>
    <para>What are the differences between Collection and Collections in Java?</para>
    <para> </para>
    <para>Main differences between Collection and Collections are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Type: Collection is an interface in Java. Collections is a class.</para>
      </listitem>
      <listitem>
        <para>Features: Collection interface provides basic features of data structure to List, Set and Queue interfaces. Collections is a utility class to sort and synchronize collection elements. It has polymorphic algorithms to operate on collections.</para>
      </listitem>
      <listitem>
        <para>Method Type: Most of the methods in Collection are at instance level. Collections class has mainly static methods that can work on an instance of Collection.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>               In which scenario, LinkedList is better than ArrayList in Java?</para>
    <para> </para>
    <para>ArrayList is more popular than LinkedList in Java due to its ease of use and random access to elements feature.</para>
    <para> </para>
    <para>But LinkedList is better in the scenario when we do not need random access to elements or there are a lot of insertion, deletion of elements.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>What are the differences between a List and Set collection in Java?</para>
    <para> </para>
    <para>Main differences between a List and a Set are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Order: List collection is an ordered sequence of elements. A Set is just a distinct collection of elements that is unordered.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Positional Access: When we use a List, we can specify where exactly we want to insert an element. In a Set there is no order, so we can insert element anywhere without worrying about order.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Duplicate: In a List we can store duplicate elements. A Set can hold only unique elements.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> What are the differences between a HashSet and TreeSet collection in Java?</para>
    <para> </para>
    <para>Main differences between a HashSet and TreeSet are:</para>
    <para> </para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Ordering: In a HashSet elements are stored in a random order. In a TreeSet, elements are stored according to natural ordering.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Null Value Element: We can store null value object in a HashSet. A TreeSet does not allow to add a null value object.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Performance: HashSet performs basic operations like add(), remove(), contains(), size() etc in a constant size time. A TreeSet performs these operations at the order of log(n) time.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Speed: A HashSet is better than a TreeSet in performance for most of operations like add(), remove(), contains(), size() etc .</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Internal Structure: a HashMap in Java internally backs a HashSet. A NavigableMap backs a TreeSet internally.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Features:  A  TreeSet has more features compared to a HashSet. It has methods like pollFirst(), pollLast(), first(), last(), ceiling(), lower() etc.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Element Comparison: A HashSet uses equals() method for comparison. A TreeSet uses compareTo() method for</para>
      </listitem>
    </orderedlist>
    <para>comparison to maintain ordering of elements.</para>
    <para> </para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>In Java, how will you decide when to use a List, Set or a Map collection?</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>What are the differences between a HashMap and a Hashtable in Java?</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>Main differences between a HashMap and a Hashtable are:</para>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para>Enumerator of the Hashtable is not fail-fast.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>What are the differences between a HashMap and a TreeMap?</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>Main differences between a HashMap and a TreeMap in Java are:</para>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>               What are the differences</para>
    <para>between Comparable and Comparator?</para>
    <para> </para>
    <para>Main differences between Comparable and Comparator are:</para>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <para>In Java, what is the purpose of Properties file?</para>
    <para> </para>
    <para>A Properties file in Java is a list of key-value pairs that can be parsed by java.util.Properties class.</para>
    <para> </para>
    <para>Generally a Properties file has extension .properties e.g. myapp.properties.</para>
    <para> </para>
    <para>Properties files are used for many purposes in all kinds of Java applications. Some of the uses are to store configuration, initial data, application options etc.</para>
    <para>When we change the value of a key in a properties file, there is no need to recompile the Java application. So it provides benefit of changing values at runtime.</para>
    <para> </para>
    <para> </para>
    <para>What is the reason for overriding equals() method?</para>
    <para> </para>
    <para>The equals() method in Object class is used to check whether two objects are same or not. If we want a custom implementation we can override this method.</para>
    <para> </para>
    <para>For example, a Person class has first name, last name and age. If we want two Person objects to be equal based on name and age, then we can override equals() method to compare the first name, last name and age of Person objects.</para>
    <para> </para>
    <para>Generally in HashMap implementation, if we want to use an object as key, then we override equals() method.</para>
    <para> </para>
    <para>How does hashCode() method work in Java?</para>
    <para> </para>
    <para>Object class in Java has hashCode() method. This method returns a hash code value, which is an integer.</para>
    <para> </para>
    <para>The hashCode() is a native method and its implementation is not pure Java.</para>
    <para> </para>
    <para>Java doesn't generate hashCode(). However, Object generates a HashCode based on the memory address of the instance of the object.</para>
    <para> </para>
    <para>If two objects are same then their hashCode() is also same.</para>
    <para> </para>
    <para> </para>
    <para>Is it a good idea to use Generics in collections?</para>
    <para> </para>
    <para>Yes. A collection is a group of elements put together in an order or based on a property. Often the type of element can vary. But the properties and behavior of a Collection remains same. Therefore it is good to create a Collection with Generics so that it is type-safe and it can be used with wide variety of elements.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>What is the difference between Collections.emptyList() and creating new instance of Collection?</para>
    <para> </para>
    <para>In both the approaches, we get an empty list. But Collections.emptyList() returns an Immutable list. We cannot add new elements to an Immutable empty list.</para>
    <para> </para>
    <para>Collections.emptyList() works like Singleton pattern. It does not create a new instance of List. It reuses an existing empty list instance.</para>
    <para> </para>
    <para>Therefore, Collections.emptylist() gives better performance if we need to get an emptyList multiple times.</para>
    <para> </para>
    <para>How will you copy elements from a Source List to another list?</para>
    <para> </para>
    <para>There are two options to copy a Source List to another list.</para>
    <para> </para>
    <para>Option 1: Use ArrayList constructor</para>
    <para> </para>
    <para>ArrayList&lt;Integer&gt; newList = new ArrayList&lt;Integer&gt;(sourceList);</para>
    <para> </para>
    <para>Option 2:  Use Collection.copy()</para>
    <para>To use Collections.copy() destination list should be of same or larger size than source list.</para>
    <para> </para>
    <para>        ArrayList&lt;Integer&gt;         newList         =         new         ArrayList&lt;Integer&gt;</para>
    <para>(sourceList.size());</para>
    <para>Collections.copy(newList, sourceList);</para>
    <para> </para>
    <para> </para>
    <para>Collections.copy() does not reallocate the capacity of destination List if it does not have enough space to contain all elements of source List. It throws IndexOutOfBoundsException.</para>
    <para> </para>
    <para>The benefit of Collection.copy() is that it guarantees that the copy will happen in linear time. It is also good for the scenario when we want to reuse an array instead of allocating more memory in the constructor of ArrayList.</para>
    <para> </para>
    <para>One limitation of Collections.copy() is that it can accept only List as source and destination parameters.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>  What are the Java Collection classes that implement List interface?</para>
    <para> </para>
    <para>Java classes that implement List interface are:</para>
    <para> </para>
    <para>AbstractList</para>
    <para>AbstractSequentialList</para>
    <para>ArrayList</para>
    <para>AttributeList</para>
    <para>CopyOnWriteArrayList</para>
    <para>LinkedList</para>
    <para>RoleList</para>
    <para>RoleUnresolvedList</para>
    <para>Stack</para>
    <para>Vector</para>
    <para> </para>
    <para> </para>
    <para> What are the Java Collection classes that implement Set interface?</para>
    <para> </para>
    <para>Java classes that implement Set interface are:</para>
    <para> </para>
    <para>AbstractSet</para>
    <para>ConcurrentSkipListSet</para>
    <para>CopyOnWriteArraySet</para>
    <para>EnumSet</para>
    <para>HashSet</para>
    <para>JobStateReasons</para>
    <para>LinkedHashSet</para>
    <para>TreeSet</para>
    <para> </para>
    <para> </para>
    <para>What is the difference between an Iterator and ListIterator in Java?</para>
    <para> </para>
    <para>Iterator and ListIterator are two interfaces in Java to traverse data structures. The differences between these two are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>ListIterator can be used to traverse only a List. But Iterator can be used to traverse List, Set, and Queue etc.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>An Iterator traverses the elements in one direction only. It just goes. ListIterator can traverse the elements in two directions i.e. backward as well as forward directions.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Iterator cannot provide us index of an element in the Data Structure. ListIterator provides us methods like nextIndex() and previousIndex() to get the index of an element during traversal.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Iterator does not allow us to add an element to collection while traversing it. It throws</para>
      </listitem>
    </orderedlist>
    <para>ConcurrentModificationException. ListIterator allows use to add an element at any point of time while traversing a list.  </para>
    <orderedlist>
      <listitem>
        <para>An existing element’s value cannot be replaced by using Iterator. ListIterator provides the method set(e) to replace the value of last element returned by next() or previous() methods.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>               What is the difference between</para>
    <para>Iterator and Enumeration?</para>
    <para> </para>
    <para>Both Iterator and Enumeration are interfaces in Java to access Data Structures. The main differences between these are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Enumeration is an older interface. Iterator is a newer interface.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Enumeration can only traverse legacy collections. Iterator can traverse both legacy as well as newer collections.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Enumeration does not provide remove() method. So we cannot remove any element during traversal. Iterator provides remove() method.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Iterator is a fail-fast interface, it gives ConcurrentModificationException if any thread tries to modify an element in the collection being iterated. Enumeration is not fail-fast.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Method names in Iterator are shorter than in an Enumeration.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>What is the difference between an ArrayList and a LinkedList data structure?</para>
    <para> </para>
    <para>Main differences between ArrayList and LinkedList data structures are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Data Structure: An ArrayList is an indexed based dynamic array. A LinkedList is a Doubly Linked List data structure.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Insertion: It is easier to insert new elements in a LinkedList, since there is no need to resize an array.</para>
      </listitem>
    </orderedlist>
    <para>Insertion in ArrayList is O(n), since it may require resizing of array and copying its contents to new array.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Remove elements: LinkedList has better performance in removal of elements than ArrayList.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Memory Usage: LinkedList uses more memory than ArrayList, since it has to maintain links for next and previous nodes as well.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Access: LinkedList is slower in accessing an element, since we have to traverse the list one by one to access the right location.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>What is the difference between a Set and a Map in Java?</para>
    <para> </para>
    <para>Main differences between a Set and a Map in Java are:</para>
    <para> </para>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>What is the use of a Dictionary class?</para>
    <para> </para>
    <para>The Dictionary class in Java is used to store key-value pairs. Any non-null object can be used for key or value. But we cannot insert a null key or null object in Dictionary.</para>
    <para> </para>
    <para>Dictionary class is deprecated now. So it should not be used in newer implementations.</para>
    <para> </para>
    <para>What is the default size of load factor in a HashMap collection in Java?</para>
    <para> </para>
    <para>Default value of load factor in a HashMap is 0.75.</para>
    <para> </para>
    <para>What is the significance of load factor in a HashMap in Java?</para>
    <para> </para>
    <para>A HashMap in Java has default initial capacity 16 and the load factor is 0.75f (i.e. 75% of current map size). The load factor of a HashMap is the level at which its capacity should be doubled.</para>
    <para> </para>
    <para>For example, in a HashMap of capacity 16 and load factor .75. The capacity will become 32 when the HashMap is 75% full. Therefore, after storing the 12th key– value pair (16 * .75 = 12) into HashMap, its capacity becomes 32.</para>
    <para> </para>
    <para> </para>
    <para>What are the major differences between a HashSet and a HashMap?</para>
    <para> </para>
    <para>The main difference between a HashSet and a HashMap are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Base class: A HashSet class implements the Set interface.</para>
      </listitem>
    </orderedlist>
    <para>Whereas a HashMap class implements the Map interface.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Storage: A HashSet is used to store distinct objects. A HashMap is used for storing key &amp; value pairs, so that these can be retrieved by key later on.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Duplicate Elements: A HashSet does not allow storing duplicate elements. A HashMap also does not allow duplicate keys. But we can store duplicate values in a HashMap.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Null Elements: In a HashSet we can store a single null value. In a HashMap we can store single null key, but any number of null values.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Element Type: A HashSet contains only values of objects as its elements. Whereas a HashMap contains entries(key value pairs).</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Iteration: By using an Iterator we can iterate a HashSet. But a HashMap has to be converted into Set for iteration.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>What are the similarities between a HashSet and a HashMap in Java?</para>
    <para> </para>
    <para>As the name suggests, HashSet and HashMap are Hashing based collections. Similarities between HashSet and HashMap are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Thread Safety: Both HashMap and HashSet are not synchronized collections. Therefore they are not good for thread-safe operations. To make these thread-safe we need to explicitly use synchronized versions.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Order of Elements: None of these classes guarantee the order of elements. These are unordered collections.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Internal Implementation: A HashMap backs up a HashSet internally. So HashSet uses a HashMap for performing its operations.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Performance: Both of these collections provide constant time performance for basic operations such as insertion and removal of elements.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>               What is the reason for overriding equals() method?</para>
    <para> </para>
    <para>The equals() method in Object class is used to check whether two objects are same or not. If we want a custom implementation we can override this method.</para>
    <para> </para>
    <para>For example, a Person class has first name, last name and age. If we want two Person objects to be equal based on name and age, then we can override equals() method to compare the first name, last name and age of Person objects.</para>
    <para> </para>
    <para>Generally in HashMap implementation, if we want to use an object as key, then we override equals() method.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>How can we synchronize the elements of a List, a Set or a Map?</para>
    <para> </para>
    <para>Sometimes we need to make collections Thread-safe for use in Multi-threading environment. In Java, Collections class provides useful static methods to make a List, Set or Map as synchronized collections. Some of these methods are:</para>
    <para> </para>
    <para>static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)</para>
    <para>Returns a synchronized (thread-safe) collection backed by the specified collection.</para>
    <para> </para>
    <para>        static &lt;T&gt; List&lt;T&gt;        synchronizedList(List&lt;T&gt; list)</para>
    <para>Returns a synchronized (thread-safe) list backed by the specified list.</para>
    <para> </para>
    <para>static &lt;K,V&gt; Map&lt;K,V&gt;synchronizedMap(Map&lt;K,V&gt; m)</para>
    <para>Returns a synchronized (thread-safe) map backed by the specified map.</para>
    <para> </para>
    <para>        static &lt;T&gt; Set&lt;T&gt;          synchronizedSet(Set&lt;T&gt; s)</para>
    <para>Returns a synchronized (thread-safe) set backed by the specified set.</para>
    <para> </para>
    <para>        static         &lt;K,V&gt;</para>
    <para>SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m) Returns a synchronized (thread-safe) sorted map backed by the specified sorted map.</para>
    <para> </para>
    <para>static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s) Returns a synchronized (thread-safe) sorted set backed by the specified sorted set.</para>
    <para> </para>
    <para> </para>
    <para>              What is Hash Collision? How</para>
    <para>Java handles hash-collision in</para>
    <para>HashMap?</para>
    <para> </para>
    <para>In a Hashing scenario, at times two different objects may have same HashCode but they may not be equal. Therefore, Java will face issue while storing the two different objects with same HashCode in a HashMap. This kind of situation is Hash Collision.</para>
    <para> </para>
    <para>There are different techniques of resolving or avoiding Hash Collision. But in HashMap, Java simply replaces the Object at old Key with new Object in case of Hash Collision.</para>
    <para> </para>
    <para>               What are the Hash Collision resolution techniques?</para>
    <para> </para>
    <para>To resolve a Hash Collision we can use one of the following techniques:</para>
    <para> </para>
    <para>Separate Chaining with Linked List</para>
    <para>Separate Chaining with List Head Cells</para>
    <para>Open Addressing with Coalesced Hashing</para>
    <para>Open Addressing with Cuckoo Hashing</para>
    <para>Hopscotch Hashing</para>
    <para>Robinhood Hashing</para>
    <para> </para>
    <para> What is the difference between Queue and Stack data structures?</para>
    <para> </para>
    <para>Queue is a FIFO data structure. FIFO stands for First In First Out. It means the element added first will be removed first from the queue. A real world example of Queue is a line for buying tickets at a station. The person entering first in the Queue is served first.</para>
    <para> </para>
    <para>Stack is a LIFO data structure. LIFO stands for Last In First Out. The element that is added last is removed first from the collection. In a Stack elements are added or removed from the top of stack.</para>
    <para> </para>
    <para>A real world example of Stack is back button in browser. We can go back one by one only and it works in the reverse order of adding webpages to history              .             </para>
    <para> </para>
    <para> </para>
    <para> What is an Iterator in Java?</para>
    <para> </para>
    <para>Iterator is an interface in Java to access the elements in a collection.</para>
    <para>It is in java.util package.</para>
    <para>It provides methods to iterate over a Collection class in Java.</para>
    <para> </para>
    <para>Iterator interface in Java is based on Iterator design pattern. By using an Iterator one can traverse a container of objects and can also access the objects in the container. A container of objects is a Collection class in Java.</para>
    <para> </para>
    <para> </para>
    <para>               What is the difference between</para>
    <para>Iterator and Enumeration in Java?</para>
    <para> </para>
    <para>Main differences between Iterator and Enumeration in Java are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Version: Enumeration interface is in Java since JDK 1.0. Iterator interface was introduced in Java 1.2.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>remove()         method:         The         main         difference         between</para>
      </listitem>
    </orderedlist>
    <para>Enumeration and Iterator interface is remove() method. Enumeration can just traverse a Collection object. If we use Enumeration, we cannot do any modifications to a Collection while traversing the collection. Iterator interface provides remove() method to remove an element while traversing the Collection. There is not remove() method in Enumeration interface.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Method names: Names of methods in Iterator interface are hasNext(), next(), remove(). Names of methods in Enumeration interface are hasMoreElements(), nextElement().</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Legacy Interface: Enumeration is considered as a legacy interface. It is used to traverse legacy classes like Vector, Stack and HashTable. Iterator is a newer interface that is used to traverse almost all of the classes in Java Collections framework.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Fail-fast vs. Fail-safe: Iterator is based on fail-fast principle. It throws ConcurrentModificationException if a collection is modified during iteration over that collection. An Enumeration is based on fail-safe principle. It doesn’t throw any exception if a collection is modified during traversal.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Safety: Since Iterator is fail-fast and does not allow modification of a collection by other threads, it is considered safer than Enumeration.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>               What is the design pattern</para>
    <para>used in the implementation of Enumeration in Java?</para>
    <para> </para>
    <para>Enumeration is based on Iterator design pattern. Iterator design pattern provides a common interface with methods to traverse the collection of objects. It hides the underlying implementation details of the collection.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>Which methods do we need to override to use an object as key in a</para>
    <para>HashMap?</para>
    <para> </para>
    <para>If we want to use an object as a key in a HashMap in Java, then we have to make sure that it has the implementation of equals() and hashCode() methods.</para>
    <para> </para>
    <para> </para>
    <para>How will you reverse a List in Java?</para>
    <para> </para>
    <para>In Collections class, Java provides a method reverse(List list) that can be used to reverse a List.</para>
    <para> </para>
    <para>E.g.</para>
    <para>Collections.reverse(myList);</para>
    <para> </para>
    <para>How will you convert an array of String objects into a List?</para>
    <para> </para>
    <para>Java provides Arrays class in java.util package. Arrays class has a method asList() that accepts an Array as input and returns a List as output.</para>
    <para> </para>
    <para>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</para>
    <para> </para>
    <para>String[]  myArray =  {"George"  , "Jack" , "Ryan"};</para>
    <para>List myList =  Arrays.asList(myArray);</para>
    <para> </para>
    <para>What is the difference between peek(), poll() and remove() methods of Queue interface in java?</para>
    <para> </para>
    <para>In a Java Queue, poll() and remove() methods can be used for removing the head object of Queue. The main difference arises in the case when Queue is empty().</para>
    <para> </para>
    <para>If Queue is empty then poll() method returns null value. If Queue is empty then remove() method throws NoSuchElementException.</para>
    <para> </para>
    <para>In a Java Queue, peek() method retrieves the head of Queue but it does not remove it. If queue is empty then peek() method returns null value.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>               What is the difference between</para>
    <para>Array and ArrayList in Java?</para>
    <para> </para>
    <para>The main differences between Array and ArrayList in Java are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Size: Array in Java is fixed in size. We cannot change the size of array after creating it. ArrayList is dynamic in size. When we add elements to an ArrayList, its capacity increases automatically.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Performance: In Java Array and ArrayList give different performance for different operations.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>add() or get(): Adding an element to or retrieving an element from an array or ArrayList object has similar performance. These are constant time operations.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>resize(): Automatic resize of ArrayList slows down the performance. ArrayList is internally backed by an Array. In resize() a temporary array is used to copy elements from old array to new array.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Primitives: Array can contain both primitive data types as well as objects. But ArrayList cannot contain primitive data types. It contains only objects.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Iterator: In an ArrayList we use an Iterator  object to traverse the elements. We use for loop for iterating elements in an array. </para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Type Safety:  Java helps in ensuring Type Safety of elements in an ArrayList by using Generics. An Array can</para>
      </listitem>
    </orderedlist>
    <para>contain objects of same type of class. If we try to store a different data type object in an Array then it throws ArrayStoreException.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Length:  Size of ArrayList can be obtained by using size() method. Every array object has length variable that is same as the length/size of the array.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Adding elements: In an ArrayList we can use add() method to add objects. In an Array assignment operator is used for adding elements.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Multi-dimension: An Array can be multi-dimensional. An ArrayList is always of single dimension.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>How will you insert, delete and retrieve elements from a HashMap collection in Java?</para>
    <para> </para>
    <para>We use following methods to insert, delete and retrieve elements in a HashMap.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Retrieve: We use get() method to retrieve elements from a HashMap.</para>
      </listitem>
    </orderedlist>
    <para>Value get(Object key)</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Insert: We use put() method to insert a key value pair in a HashMap.</para>
      </listitem>
    </orderedlist>
    <para>Value put(Key k, Value v)</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Delete: We use remove() method to delete key-value pair from the HashMap.</para>
      </listitem>
    </orderedlist>
    <para>Value remove(Object key)</para>
    <para> </para>
    <para> </para>
    <para> What are the main differences between HashMap and</para>
    <para>ConcurrentHashMap in Java?</para>
    <para> </para>
    <para>Main differences between HashMap and ConcurrentHashMap are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Synchronization: A HashMap is not synchronized. But a ConcurrentHashMap is a synchronized object.</para>
      </listitem>
      <listitem>
        <para>Null Key: A HashMap can have one null key and any number of null values. A ConcurrentHashMap cannot have null keys or null values.</para>
      </listitem>
      <listitem>
        <para>Multi-threading: A ConcurrentHashMap works well in a multi-threading environment.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>What is the increasing order of performance for following collection classes in Java?</para>
    <para> </para>
    <para>The increasing order of performance is:</para>
    <para> </para>
    <para>Hashtable   </para>
    <para>Collections.SynchronizedMap</para>
    <para>ConcurrentHashMap</para>
    <para>HashMap</para>
    <para> </para>
    <para>Hashtable has the worst performance and HashMap has the best performance.</para>
    <para> </para>
    <para> </para>
    <para>               Why does Map interface not extend Collection interface in Java?</para>
    <para> </para>
    <para>A Map is a collection objects. But Map interface is not compatible with Collection interface in Java.</para>
    <para> </para>
    <para>A Map requires key as well as a value. So it requires two parameters to add an element to a HashMap.</para>
    <para> </para>
    <para>But Collection interface provides add(Object o) method with only one parameter.</para>
    <para> </para>
    <para>Map collection has to provide methods like valueSet, keySet etc. These methods are specific to Map collection. Where as methods in Collection interface can be reused by a List, Set, Queue etc.</para>
    <para> </para>
    <para> </para>
    <para>What are the different ways to iterate elements of a list in Java?</para>
    <para> </para>
    <para>There are mainly two ways to iterate the elements of list in Java:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Iterator: We can get an Iterator for list and use it to iterate the objects of the list.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>For-each loop: We can use for-each loop to traverse all the elements of a list.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>              What is</para>
    <para>CopyOnWriteArrayList?  How it is different from ArrayList in Java?</para>
    <para> </para>
    <para>CopyOnWriteArrayList was introduced in Java 5 version. It is a thread-safe collection. It is similar to an ArrayList.</para>
    <para> </para>
    <para>In CopyOnWriteArrayList, all mutative operations (add, set etc.) are implemented by making a fresh copy of the underlying array.</para>
    <para> </para>
    <para>Iterator of CopyOnWriteArrayList is guaranteed to not throw ConcurrentModificationException. But Iterator also does not reflect any additions, removals that happened to list after the Iterator was created.</para>
    <para> </para>
    <para>All elements including null are permitted in CopyOnWriteArrayList.</para>
    <para> </para>
    <para> </para>
    <para>How remove() method is implemented in a HashMap?</para>
    <para> </para>
    <para>Remove() method in HashMap uses logic similar to the one used in get() method. First we locate the correct bucket in HashMap for an entry. Then within that bucket we remove the element e. It is similar to removing a node from a single-linked list.</para>
    <para> </para>
    <para>If e is the first element in the bucket we set the corresponding element of Hash to e.next. Else we set the next field of the element just before e to e.next.</para>
    <para>              What is BlockingQueue in</para>
    <para>Java Collections?</para>
    <para> </para>
    <para>BlockingQueue was introduced in Java 1.5. It extends Queue interface in Java.</para>
    <para> </para>
    <para>BlockingQueue supports operations that wait for the queue to become non-empty when retrieving an element. Also it supports the operations that wait for space to become available in the queue while storing an element.</para>
    <para> </para>
    <para>Some of the features of BlockingQueue are:</para>
    <para> </para>
    <para>It does not accept null elements.</para>
    <para>Its main use is in producer-consumer problems.</para>
    <para>BlockingQueue implementation is thread-safe.</para>
    <para>It can be used in inter-thread communications.</para>
    <para>It does not support any kind of "close" or "shutdown" operation to indicate that no more items will be added.</para>
    <para> </para>
    <para>How is TreeMap class implemented in Java?</para>
    <para> </para>
    <para>Internally, a TreeMap class in Java uses Red-Black tree.</para>
    <para> </para>
    <para>It is a NavigableMap. The map sorts the keys in natural order or it can use a Comparator supplied at the creation time.</para>
    <para> </para>
    <para>The implementation of TreeMap is not synchronized in Java.</para>
    <para> </para>
    <para>             What is the difference between</para>
    <para>Fail-fast and Fail-safe iterator in Java?</para>
    <para> </para>
    <para>Differences between Fail-fast and Fail-safe iterators are as follows:</para>
    <para> </para>
    <para>Fail-fast iterator throws ConcurrentModificationException. But Fail-safe iterator does not throw this exception.</para>
    <para> </para>
    <para>Fail-fast iterator does not clone the original collection. Fail-safe iterator creates a copy of the original collection of objects.</para>
    <para> </para>
    <para>A Fail-fast iterator tries to immediately throw Exception when it encounters failure. A Fail-safe Iterator works on a copy of collection instead of original collection.</para>
    <para> </para>
    <para>How does</para>
    <para>ConcurrentHashMap work in Java?</para>
    <para> </para>
    <para>ConcurrentHashMap extends AbstractMap in Java. It was introduced in Java 1.5. It provides concurrency in a collection based on a HashMap.</para>
    <para> </para>
    <para>All methods are thread-safe in ConcurrentHashMap.</para>
    <para> </para>
    <para>Internally there is a Hashtable backing a ConcurrentHashMap. This Hashtable supports the concurrent methods for retrieval of data as well as updates on ConcurrentHashMap.</para>
    <para> </para>
    <para>It has same functional specification as a Hashtable.</para>
    <para> </para>
    <para>It also supports a set of sequential and bulk operations. These operations accept parallelismThreshold argument.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>What is the importance of hashCode() and equals() methods?</para>
    <para> </para>
    <para>In a HashMap collection it is very important for a key object to implement hashCode() method and equals() method. If hashCode() method returns same hashcode for all key objects then the hash collision will be high in HashMap. Also with same hashcode, we will get same equals method that will make our HashMap inefficient.</para>
    <para> </para>
    <para>The problem arises when HashMap treats both outputs same instead of different. It will overwrite the most recent key-value pair with the previous key-value pair.</para>
    <para> </para>
    <para>So it is important to implement hashCode() and equals() methods correctly for an efficient HashMap collection.</para>
    <para> </para>
    <para>What is the contract of hashCode() and equals() methods in Java?</para>
    <para> </para>
    <para>Contract of hashCode() and equals() methods is as follows in Java:</para>
    <para> </para>
    <para>If                  object1.equals(object2),         then                  object1.hashCode()         == object2.hashCode() should always be true. It means if two objects are equal then their hashCode should be same.</para>
    <para> </para>
    <para>If object1.hashCode() == object2.hashCode() is true, it does not guarantee that object1.equals(object2). It means if two objects have same hashCode, then can still have different values so that may not be equal objects.</para>
    <para> </para>
    <para>             What is an EnumSet in Java?</para>
    <para> </para>
    <para>Set: EnumSet is a specialized implementation of Set.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Use: It is mainly used with enum types.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Single enum type: All the elements in an EnumSet must come from a single enum type when the set is created.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Bit vector: Internally, EnumSet is represented as bit vector.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Iterator: The iterator of EnumSet traverses the elements in their natural order. (It is the order in which the enum constants are declared).</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Null: In an EnumSet, null elements are not permitted. If we try to insert a null element it throws NullPointerException.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Thread-safe: EnumSet is not a synchronized collection. For use in multi-threading scenarios, EnumSet should be synchronized.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Bit flags: EnumSet is a very good alternative to int based “bit flags” implementation.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>What are the main Concurrent Collection classes in Java?</para>
    <para> </para>
    <para>Java 1.5 has provided new package java.util.concurrent. This package contains thread-safe collection classed. These collection classes can be modified while iterating. The iterator of these classes is fail-safe.</para>
    <para> </para>
    <para>Main Concurrent Collection classes in Java 8 are:</para>
    <para> </para>
    <para>ArrayBlockingQueue</para>
    <para>CopyOnWriteArrayList</para>
    <para>CopyOnWriteArraySet</para>
    <para>ConcurrentHashMap</para>
    <para>ConcurrentLinkedDeque</para>
    <para>ConcurrentLinkedQueue</para>
    <para>LinkedBlockingQueue</para>
    <para>LinkedBlockingDeque</para>
    <para>PriorityBlockingQueue</para>
    <para> </para>
    <para> </para>
    <para>How will you convert a Collection to SynchronizedCollection in Java?</para>
    <para> </para>
    <para>Java provides an easy method in java.utils.Collections class to create a ThreadSafe collection from a regular collection. </para>
    <para> </para>
    <para>We can use the method synchronizedCollection() for this purpose.</para>
    <para> </para>
    <para>For any class of type T we can use following method:</para>
    <para> </para>
    <para>static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)</para>
    <para> </para>
    <para>How IdentityHashMap is different from a regular Map in Java?</para>
    <para> </para>
    <para>IndentityHashMap in Java implements Map interface. But it is not a general purpose implementation. It violates the general contract of Map interface by a different implementation of equals() method.</para>
    <para> </para>
    <para>In an IdentityHashMap, two keys k1 and k2 are equal if and only if (k1==k2). (In a normal Map implementation (like HashMap) two keys k1 and k2 are considered equal if and only if (k1==null ?</para>
    <para>k2==null : k1.equals(k2)).)</para>
    <para> </para>
    <para>It implements the Map interface with a hash table, using referenceequality in place of object-equality when comparing keys (and values).</para>
    <para> </para>
    <para> </para>
    <para>What is the main use of IdentityHashMap?</para>
    <para> </para>
    <para>Main uses of IdentityHashMap are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Topology         Preservation:         The         typical         use         of</para>
      </listitem>
    </orderedlist>
    <para>IdentityHashMap class is topology-preserving object graph transformations, such as serialization or deepcopying. In such a scenario, a program must maintain a</para>
    <para>"node table" to  keep track of all the object references that have already been processed.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>The node table should not considered distinct objects as equal even if they happen to be equal.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Proxy objects: Another use of this class is to maintain proxy objects. A debugging program has to maintain a proxy object for each object in the program being debugged.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>How can we improve the performance of IdentityHashMap?</para>
    <para> </para>
    <para>IdentityHashMap class has one tuning parameter for performance improvement: expectedMaxSize.</para>
    <para> </para>
    <para>This parameter is the maximum number of key-value mappings that the map is expected to hold.</para>
    <para> </para>
    <para>We can use this parameter is used to determine the number of buckets initially in the hash table. The precise relationship between the expected maximum size and the number of buckets is unspecified.</para>
    <para> </para>
    <para>If the number of key-value mappings exceeds the expected maximum size, the number of buckets is increased.</para>
    <para> </para>
    <para>Increasing the number of buckets is also known as rehashing. Rehashing may be fairly expensive. So it is better to create identity hash maps with a sufficiently large expected maximum size.</para>
    <para> </para>
    <para>But iteration over a Map collection requires time proportional to the number of buckets in the hash table. So iteration may take extra time due to large number of buckets.</para>
    <para> </para>
    <para>Therefore the value of expectedMaxSize should be set in consideration with both of these aspects.</para>
    <para> </para>
    <para>               Is IdentityHashMap threadsafe?</para>
    <para> </para>
    <para>The implementation of IdentityHashMap is not thread-safe, since its methods are not synchronized.</para>
    <para> </para>
    <para>The iterators returned by the iterator method of IdentityHashMap are fail-fast. But the fail-fast behavior of an iterator cannot be guaranteed.</para>
    <para> </para>
    <para>Since         the         Iterator         is         fail-fast,         it         throws</para>
    <para>ConcurrentModificationException.</para>
    <para> </para>
    <para>What is a WeakHashMap in Java?</para>
    <para> </para>
    <para>WeakHashMap is a class similar to IdentityHashMap.</para>
    <para> </para>
    <para>Internally, it is represented by a Hashtable.</para>
    <para> </para>
    <para>It is not a synchronized class. We can make a WeakHashMap thread safe by using Collections.synchronizedMap() method.</para>
    <para> </para>
    <para>An entry in WeakHashMap is automatically removed when it is no longer in ordinary use.</para>
    <para> </para>
    <para>The presence of a mapping for a given key does not prevent the key from being discarded by the garbage collector.</para>
    <para> </para>
    <para>WeakHashMap also permits null keys and null values.</para>
    <para> </para>
    <para> How can you make a Collection class read Only in Java?</para>
    <para> </para>
    <para>In Java, there are useful methods to make a Collection class read Only. We can make the Collection read Only by using one of the following methods:</para>
    <para> </para>
    <para> </para>
    <para><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/><para/>Collections.unmodifiableMap(Map m)</para>
    <para>Collections.unmodifiableList(List l)</para>
    <para>Collections.unmodifiableSet(Set s)</para>
    <para>Collections.unmodifiableCollection(Collection c)</para>
    <para> </para>
    <para> </para>
    <para>When is</para>
    <para>UnsupportedOperationException thrown in Java?</para>
    <para> </para>
    <para>In a Java collection UnsupportedOperationException is thrown when the requested operation is not supported by the collection.</para>
    <para> </para>
    <para>It is an unchecked exception that is thrown on optional operations.</para>
    <para> </para>
    <para>If there is an optional add() or remove() methods in a read only collection, then this exception can be thrown.</para>
    <para> </para>
    <para> </para>
    <para>               Let say there is a Customer</para>
    <para>class. We add objects of Customer class to an ArrayList. How can we sort the Customer objects in ArrayList by using customer firstName attribute of Customer class?</para>
    <para> </para>
    <para>There are two ways to handle this scenario. We can use these options:</para>
    <para>Comparable: Implement the Comparable interface for Customer class and compare customer objects by firstName attribute.</para>
    <para> </para>
    <para>Comparator: Implement Comparator for comparing two Customer objects on the basis of firstName attribute. Then use this comparator object in sort method of Collections class.</para>
    <para> </para>
    <para> </para>
    <para>What is the difference between Synchronized Collection and Concurrent Collection?</para>
    <para> </para>
    <para>In Java 1.5 many Concurrent collection classes were added in SDK. These are ConcurrentHashMap, CopyOnWriteArrayList,</para>
    <para>BlockingQueue etc.</para>
    <para> </para>
    <para>Java also provides utility methods to get a synchronized copy of collection like ArrayList, HashMap etc. by using</para>
    <para>Collections.synchronizedList(), Collections.synchronizedMap() methods.</para>
    <para> </para>
    <para>The main difference is in performance. Concurrent collection classes have better performance than synchronized collection classes because they lock only a portion of the class to achieve concurrency and thread-safety.</para>
    <para> </para>
    <para>              What is the scenario to use</para>
    <para>ConcurrentHashMap in Java?</para>
    <para> </para>
    <para>ConcurrentHashMap is more suited for scenarios where we have multiple reader threads and one writer thread. In this case map is locked only during the write operation.</para>
    <para> </para>
    <para>If we have an equal number of reader and writer threads then ConcurrentHashMap performance is similar to a Hashtable or a synchronized HashMap.</para>
    <para> </para>
    <para> </para>
    <para>How will you create an empty Map in Java?</para>
    <para> </para>
    <para>There are two ways to create an empty Map in Java.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Immutable: If we want an immutable empty Map, we can use following code:</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>myMap = Collections.emptyMap();</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Any map: For all other scenarios, we can use following code by using new method:</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>myMap = new HashMap();</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>222.              What is the difference between remove() method of Collection and remove() method of Iterator?</para>
    <para> </para>
    <para>In Collection interface remove(Object o) method is used to remove objects from a Collection.</para>
    <para> </para>
    <para>List interface also provides remove(int index) method to remove an object at a specific index.</para>
    <para> </para>
    <para>These methods are used to remove an entry from Collection, while no thread is iterating over it.</para>
    <para> </para>
    <para>When we are iterating over a Collection, then we have to remove() method of Iterator. This method removes current element from Iterator’s point of view. If we use remove(0 method of Collection or List, then we will get ConcurrentModificationException.</para>
    <para> </para>
    <para>Therefore, it is recommended to use remove() method of Iterator during the traversal of a Collection by an Iterator.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>Between an Array and ArrayList, which one is the preferred collection for storing objects?</para>
    <para> </para>
    <para>An ArrayList is backed up by array internally. There are many usability advantages of using an ArrayList over an array in Java.</para>
    <para> </para>
    <para>Array has a fixed length at the time of creation. Once it is created we cannot change its length.</para>
    <para> </para>
    <para>ArrayList is dynamic in size. Once it reaches a threshold, it automatically allocates a new array and copies contents of old array to new array.</para>
    <para> </para>
    <para>Also ArrayList provides support of Generics. But Array does not support Generics.</para>
    <para> </para>
    <para>E.g. If we store an Integer object in a String array at Runtime it will throw ArrayStoreException. Whereas, if we use ArrayList then as compile time we will get the error. This helps in preventing errors from happening at runtime.</para>
    <para> </para>
    <para>If we know the size in advance and do not need re-sizing the collection then Array should be used in place of an ArrayList.</para>
    <para> </para>
    <para> </para>
    <para>             Is it possible to replace</para>
    <para>Hashtable with ConcurrentHashMap in Java?</para>
    <para> </para>
    <para>Yes, a ConcurrentHashMap can be replaced with Hashtable in Java.</para>
    <para> </para>
    <para>But it requires careful observation, since locking behavior of Hashtable is different than that of ConcurrentHashmap.</para>
    <para> </para>
    <para>A Hashtable locks whole Map instead of a portion of Map. Compound operations like if(Hashtable.get(key) == null) put(key, value) work in Hashtable but not in ConcurrentHashMap.</para>
    <para> </para>
    <para>In a ConcurrentHashMap we use putIfAbsent() method for such a scenario.</para>
    <para> </para>
    <para> </para>
    <para>How CopyOnWriteArrayList</para>
    <para>class is different from ArrayList and Vector classes?</para>
    <para> </para>
    <para>CopyOnWriteArrayList was introduced in Java 1.5. It implements List interface.</para>
    <para> </para>
    <para>It provides better concurrent access methods than a Synchronized List.</para>
    <para> </para>
    <para>In CopyOnWriteList, concurrency is achieved by copying ArrayList over each write and replace with original instead of locking.</para>
    <para> </para>
    <para>        CopyOnWriteArrayList         also         does         not         throw         any</para>
    <para>ConcurrentModification Exception during Iteration.</para>
    <para> </para>
    <para>It is a thread-safe list.</para>
    <para> </para>
    <para>It is different from a Vector in terms of Concurrency. CopyOnWriteArrayList provides better Concurrency by reducing contention among readers and writers.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>Why ListIterator has add() method but Iterator does not have?</para>
    <para> </para>
    <para>ListIterator can iterate in the both directions of a Collection. It maintains two pointer for previous and next element. In ListIterator we can use add() method to add an element into the list immediately before the element returned by next() method.</para>
    <para> </para>
    <para>So a subsequent call to next() method will not be affected. And the call to previous() method will return the newly added element.</para>
    <para> </para>
    <para>In Iterator we can only traverse in one direction. So there is no purpose of add() method there.</para>
    <para> </para>
    <para> </para>
    <para>Why do we sometime get ConcurrentModificationException during iteration?</para>
    <para> </para>
    <para>When we remove an object by using remove() method of a</para>
    <para>Collection or List while an Iterator thread is traversing it, we get ConcurrentModificationException. If an Iterator detects any structural change in Collection it can throw</para>
    <para>ConcurrentModificationException. </para>
    <para> </para>
    <para> </para>
    <para>             How will you convert a Map to a List in Java?</para>
    <para> </para>
    <para>In Java, a Map has three collection sets:</para>
    <para> </para>
    <para>key set value set</para>
    <para>key-value set</para>
    <para> </para>
    <para>Each of these Sets can be converted to List by using a constructor.</para>
    <para> </para>
    <para>Sample code is as follows:</para>
    <para> </para>
    <para>List keyList = new ArrayList(map.keySet());</para>
    <para>List valueList = new ArrayList(map.values());</para>
    <para>List entryList = new ArrayList(map.entrySet());</para>
    <para> </para>
    <para>How can we create a Map with reverse view and lookup in Java?</para>
    <para> </para>
    <para>In a Map we can lookup for a value by using a distinct key. In a Map with reverse view and lookup, even the values are distinct. So there is one to one mapping between keys and values and vice version.</para>
    <para> </para>
    <para>If we enable this constraint on a Map then we can look up a key by its value. Such data structure is called bi-directional map.</para>
    <para> </para>
    <para>There is no built data structure similar to reverse lookup Map in JDK.</para>
    <para> </para>
    <para>But Apache Common Collections and Guava libraries provide implementation of bidirectional map. It is called BidiMap and BiMap. Both of these data structure enforce the constraint of one to one mapping between keys and values.</para>
    <para> </para>
    <para>              How will you create a shallow copy of a Map?</para>
    <para> </para>
    <para>In Java, most implementations of Map interface provide a constructor to create copy of another map. But the copy method is not synchronized.</para>
    <para> </para>
    <para>Therefore, when a thread is copying the map, another thread can modify it.</para>
    <para> </para>
    <para>To         prevent         such         a         scenario,         we         should         use Collections.synchronizedMap() method to first create a thread-safe map.</para>
    <para> </para>
    <para>Another way of to create a shallow copy is by using clone() method.</para>
    <para>But it is not considered as a recommended approach.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> Why we cannot create a generic array in Java?</para>
    <para> </para>
    <para>Java does not allow creation of array with generics as elements. </para>
    <para> </para>
    <para>In Java an array has to know the type information of its elements at runtime.</para>
    <para> </para>
    <para>This information is used at runtime to throw ArrayStoreException if data type of an element to be inserted does not match the type of Array.</para>
    <para> </para>
    <para>In case of Generics, the type information of a collection is erased at runtime by Type Erasure. Due to this array cannot use generics as elements.</para>
    <para> </para>
    <para>              What is a PriorityQueue in</para>
    <para>Java?</para>
    <para> </para>
    <para>A PriorityQueue is data structure based on Queue. Unlike Queue, the elements on PriorityQueue are not returned in FIFO order.</para>
    <para> </para>
    <para>A PriorityQueue maintains the natural order of its elements or it uses a Comparator provided at initialization.</para>
    <para> </para>
    <para>It is an unbounded queue based on a priority heap.</para>
    <para> </para>
    <para>PriorityQueue does not allow null values. We cannot add any object that does not provide natural ordering to PriorityQueue.</para>
    <para> </para>
    <para>PriorityQueue in Java is not thread-safe.</para>
    <para> </para>
    <para>It gives O(log n) time for enqueing and dequeing operations.</para>
    <para> </para>
    <para> </para>
    <para>              What are the important points</para>
    <para>to remember while using Java Collections Framework?</para>
    <para> </para>
    <para>Some of the important points to remember while using Java Collections Framework are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Interfaces: For Collections, we should write code with generic interfaces instead of concrete implementation. Due to this we maintain the flexibility of changing the implementation at a later point of time.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Generics: We should use Generics for type-safety and to avoid ClassCastException at runtime.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Collections: It is recommended to use Collections utility class for algorithms and various other common methods for Collections.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Right Type: We have to choose the right type of Java collection based on our need. If size is fixed, we can use Array over ArrayList. If we do not want duplicate elements we use Set.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>If we need the ability to iterate the elements of a Map in the order of insertion then we use a TreeMap.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Initial Size: In some collection classes we can specify the initial size/capacity. Therefore we should have an estimate of number of elements in a Collection before deciding the right collection type. We can use it to avoid rehashing or resizing.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Map: We should use immutable classes provided by Java as key elements in a Map.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para>             How can we pass a Collection</para>
    <para>as an argument to a method and ensure that method will not be able to modify it?</para>
    <para> </para>
    <para>To ensure that a method is not able to modify a Collection passed as an argument, we have to make the Collection read only.</para>
    <para> </para>
    <para>        We         can         make         a         read         only         collection         by         using</para>
    <para>Collections.unmodifiableCollection(Collection c) method.</para>
    <para> </para>
    <para>This will make sure that any operation to change the collection will throw UnsupportedOperationException.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>Can you explain how HashMap works in Java?</para>
    <para> </para>
    <para>In Java, a HashMap works on the concept of hashing.</para>
    <para> </para>
    <para>A HashMap in Java stores both key and value objects, in a bucket. It is stored as an Entry object that implements Map.Entry interface.</para>
    <para> </para>
    <para>The key object used in a HashMap has to provide implementation for hashCode() and equals() methods.</para>
    <para> </para>
    <para>When put() method is used to store a key-value pair, the HashMap implementation calls hashCode() method on Key object to calculate a hash that is used to find a bucket where Entry object will be stored.</para>
    <para> </para>
    <para>When get() method is used to retrieve a value stored against a key object, we first calculate a hash of Key object. Then we use this hash to find the bucket in which that particular key is stored.</para>
    <para> </para>
    <para>Once Key object’s location is found, it may happen that more than one Key is stored in same location. So now we use equals() method to find the exact Key object. Once the exact Key object is found we use it to get Value object.</para>
    <para> </para>
    <para>Can you explain how HashSet is implemented in Java?</para>
    <para> </para>
    <para>Internally, a HashSet uses a HashMap to store the elements and to maintain the uniqueness of elements.</para>
    <para> </para>
    <para>When we create a HashSet object, a corresponding HashMap object is also created.</para>
    <para> </para>
    <para>When we insert an element in HashSet, it inserts it into corresponding HashMap.</para>
    <para> </para>
    <para>What is a NavigableMap in Java?</para>
    <para> </para>
    <para>As the name suggests, NavigableMap provides the capability to navigate the keys of a Map in Java. A NavigableMap extends SortedMap interface.</para>
    <para> </para>
    <para>Some of the interesting methods of a NavigableMap are descendingKeySet(), descendingMap(), headMap() and tailMap().</para>
    <para>What is the difference between descendingKeySet() and descendingMap() methods of NavigableMap?</para>
    <para> </para>
    <para>The descendingKeySet() method of NavigableMap returns a NavigableSet in which the elements are stored in reversed order as compared to the original key set.</para>
    <para> </para>
    <para>The returned view is internally represented by the original KeySet of NavigableMap. Therefore any changes to the descending set also get reflected in the original set.</para>
    <para> </para>
    <para>But it is not recommended to remove elements directly from the key set. We should use the Map.remove() method.</para>
    <para> </para>
    <para>The descendingMap() method of NavigableMap returns a NavigableMap which is an inverse view of the original Map. The order of the elements in this view are in reverse order of the elements in original map. Any changes to this view are also reflected in the original map.</para>
    <para> </para>
    <para>What is the advantage of NavigableMap over Map?</para>
    <para> </para>
    <para>The main advantage of NavigableMap over Map is the Navigation capability.</para>
    <para> </para>
    <para>It provides the capabilities of a Map, SortedMap and navigation in one collection.</para>
    <para> </para>
    <para>It even returns the closest matches for given search targets.</para>
    <para> </para>
    <para>Methods like lowerEntry, floorEntry, ceilingEntry, and higherEntry return Map.Entry objects associated with keys respectively less than, less than or equal, greater than or equal, and greater than a given key.</para>
    <para> </para>
    <para>Methods like lowerKey, floorKey, ceilingKey, and higherKey return only the associated keys. All of these methods are designed for locating, not traversing entries.</para>
    <para> </para>
    <para>What is the difference between headMap(), tailMap() and subMap() methods of NavigableMap?</para>
    <para> </para>
    <para> </para>
    <para>        The         headMap()         method         returns         a         view         of         the         original</para>
    <para>NavigableMap that contains the elements that are less than a given element.</para>
    <para> </para>
    <para> </para>
    <para>NavigableMap original = new TreeMap();</para>
    <para>original.put("1", "1"); original.put("2", "2"); original.put("3", "3");</para>
    <para> </para>
    <para>//this headmap1 will contain elements "1" and "2"</para>
    <para>SortedMap headmap1 = original.headMap("3");</para>
    <para> </para>
    <para>//this headmap2 will contain elements "1", "2", and "3" because</para>
    <para>"inclusive"=true</para>
    <para>NavigableMap headmap2 = original.headMap("3", true);</para>
    <para> </para>
    <para> </para>
    <para>The tailMap() method works similar to headMap() method, but it returns all elements that are higher than the given input element.</para>
    <para> </para>
    <para>The subMap() method accepts two parameters demarcating the boundaries of the view map to return.</para>
    <para> </para>
    <para>All the three methods return a subset of the original map in a view form.</para>
    <para> </para>
    <para> </para>
    <para>               How will you sort objects by</para>
    <para>Natural order in a Java List?</para>
    <para> </para>
    <para>We can use Collections.sort method to sort the elements of a List in natural order. To use this method, we have to make sure that element objects implement compareTo() method.</para>
    <para> </para>
    <para>We can also use a Comparator to define the natural ordering for elements of a List. Then we can use this Custom Comparator in sort method of Collections class.</para>
    <para> </para>
    <para>How can we get a Stream from a List in Java?</para>
    <para> </para>
    <para>From Java 8 onwards it is a very easy to get a Stream from a List. We can just use stream() method to get a stream from a list of elements.</para>
    <para> </para>
    <para>             Can we get a Map from a</para>
    <para>Stream in Java?</para>
    <para> </para>
    <para>Yes, we can create a Map from the elements of a Stream. We can use map() method to get a Map.</para>
    <para> </para>
    <para>E.g. items.stream()</para>
    <para>     .map( item -&gt; item.toLowerCase() )</para>
    <para> </para>
    <para>In this example we are creating a map with each item object mapped to its LowerCase equivalent.</para>
    <para> </para>
    <para>This is also used in Map-Reduce implementation on a Stream.</para>
    <para>What are the popular implementations of Deque in Java?</para>
    <para> </para>
    <para> </para>
    <para>The two most popular implementation of Deque interface in Java are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>ArrayDeque: It is a resizable array implementation of Deque. The capacity of ArrayDeque can increase based on the need of the program. It is not thread safe implementation. Also the iterator on ArrayDeque is failfast.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>LinkedList: This is another popular implementation of Deque interface in Java. It is also not synchronized, so it is not thread-safe. It mainly provides functionality of a doubly linked list.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
  </sect1>
  <sect1>
    <title>Multi-threading</title>
    <para> </para>
    <para> </para>
    <para>What is a Thread in Java?</para>
    <para> </para>
    <para>A thread in Java is a lightweight process that runs within another process or thread.</para>
    <para> </para>
    <para>It is an independent path of execution in an application. JVM gives each thread its own method-call stack.</para>
    <para> </para>
    <para>When we start JVM, Java starts one thread.  This thread calls the main method of the class passed in argument to java call.</para>
    <para> </para>
    <para>What is the priority of a Thread and how it is used in scheduling?</para>
    <para> </para>
    <para>In Java, every Thread has a priority. This priority is specified as a number between 1 to 10.</para>
    <para> </para>
    <para>Scheduler in Java schedules different threads based on the priority of a thread. It is also known as pre-emptive scheduling.</para>
    <para> </para>
    <para>The thread with higher priority gets preference in execution over a thread with lower priority.</para>
    <para> </para>
    <para>What is the default priority of a thread in Java?</para>
    <para> </para>
    <para>In Java, a new thread gets the same priority as the priority of the parent thread that creates it.</para>
    <para> </para>
    <para>Default priority of a thread is 5 (NORM_PRIORITY).</para>
    <para> </para>
    <para>What are the three different priorities that can be set on a Thread in Java?</para>
    <para> </para>
    <para>We can set following three priorities on a Thread object in Java:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>MIN_PRIORITY: This is the minimum priority that a thread can have.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>NORM_PRIORITY: This is the default priority that is assigned to a thread.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>MAX_PRIORITY: This is the maximum priority that a thread can have.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>Default priority of a thread is 5 NORM_PRIORITY. The value of MIN_PRIORITY is 1 and the value of MAX_PRIORITY is 10.</para>
    <para> </para>
    <para>What is the purpose of join() method in Thread class?</para>
    <para> </para>
    <para>In Java, Thread Scheduler controls thread scheduling. But we can use join() method on a thread to make current thread to wait for another thread to finish.</para>
    <para> </para>
    <para>When we use join(), the current thread stops executing. It wait for the thread on which join() is called to finish.</para>
    <para> </para>
    <para>This makes sure that current thread will continue only after the thread it joined finished running. Consider following example:</para>
    <para> </para>
    <para>Public class ThreadJoin {</para>
    <para> Thread importantThread = new Thread(                new Runnable() {                    public void run () {</para>
    <para>                       //do something</para>
    <para>                   }</para>
    <para>                }</para>
    <para>  );</para>
    <para>  Thread currentThread = new Thread(                new Runnable() {                    public void run () {</para>
    <para>                       //do something</para>
    <para>                   }</para>
    <para>                }</para>
    <para>  );</para>
    <para>  importantThread.start(); // Line 1   importantThread.join();  // Line 2</para>
    <para>  currentThread.start(); // Line 3</para>
    <para>}</para>
    <para> </para>
    <para>In the above example, main thread is executing. On Line 1, a new thread called importantThread is ready to run. But at Line 2, main</para>
    <para>thread joins the importantThread. Now it lets importantTread to finish and then it moves to Line 3. So currentThread at Line 3 will not start till the importantThread has finished.</para>
    <para> </para>
    <para> </para>
    <para>              What is the fundamental</para>
    <para>difference between wait() and sleep() methods?</para>
    <para> </para>
    <para> </para>
    <para>The main difference between wait() and sleep() is that wait is an Object level method, whereas sleep() is a static method in Thread class. A waiting thread can be woken up by another thread by calling notify() on the monitor which is being waited on. But a sleeping thread cannot be woken up.</para>
    <para> </para>
    <para>A wait() and notify() has to happen within the same block that is synchronized on the monitor object.</para>
    <para> </para>
    <para>When we call wait() the current thread releases the monitor and goes to waiting state. Then another thread calls notify() to wake it up.</para>
    <para> </para>
    <para>In case of sleep() current thread does not release the monitor or locks. It just sleeps for some pre-defined time period.</para>
    <para> </para>
    <para> </para>
    <para> Is it possible to call run() method instead of start() on a thread in Java?</para>
    <para> </para>
    <para>Yes. We can call run() method of a thread. But it does not work as a separate thread. It will just work as a normal object in main thread and there will not be context switching between the threads.</para>
    <para> </para>
    <para> </para>
    <para>              How Multi-threading works in</para>
    <para>Java?</para>
    <para> </para>
    <para>Java provides support for Multithreading. In a Multithreading environment, one process can execute multiple threads in parallel at the same time.</para>
    <para> </para>
    <para>In Java, you can create process and then create multiple threads from that process. Each process can execute in parallel to perform independent tasks.</para>
    <para> </para>
    <para>Java provides methods like- start(), notify(), wait(), sleep() etc. to maintain a multi-threading environment.</para>
    <para> </para>
    <para>What are the advantages of Multithreading?</para>
    <para> </para>
    <para>Main advantages of Multithreading are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Improved performance: We can improve performance of a job by Multi-threading.</para>
      </listitem>
      <listitem>
        <para>Simultaneous access to Multiple Applications: We can access  multiple applications from a process by doing multithreading</para>
      </listitem>
      <listitem>
        <para>Reduced number of Servers required: With Multithreading we need lesser number of servers, since one process can spawn multiple threads.</para>
      </listitem>
      <listitem>
        <para>Simplified Coding: In certain scenarios, it is easier to code multiple threads than managing it from same thread.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>             What are the disadvantages of</para>
    <para>Multithreading?</para>
    <para> </para>
    <para>There are certain downsides to Multithreading. These are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Difficult to Debug: Multithreading code is difficult to debug in case of an issue.</para>
      </listitem>
      <listitem>
        <para>Difficult to manage concurrency: Due to multiple threads, we may experience different kinds of issues.</para>
      </listitem>
      <listitem>
        <para>Difficulty of porting code: It is difficult to convert existing single threaded code into multi-threading code.</para>
      </listitem>
      <listitem>
        <para>Deadlocks: In case of multi-threading we can experience deadlocks in threads that are waiting for same resource.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>What is a Thread in Java?</para>
    <para> </para>
    <para>In Java, a thread is a lightweight process that runs within another process or thread. It is an independent path of execution in an application. Each thread runs in a separate stack frame.</para>
    <para> </para>
    <para>By default Java starts one thread when the main method of a class is called.</para>
    <para> </para>
    <para> </para>
    <para>What is a Thread’s priority and how it is used in scheduling?</para>
    <para> </para>
    <para>In Java, every Thread has a priority. This priority is specified as an integer value. The priority value is used in scheduling to pick up the thread with higher priority for execution. The threads with higher priority get more preference in execution than the threads with lower priority.</para>
    <para> </para>
    <para>The task scheduler schedules the higher priority threads first, followed by the lower priority threads.</para>
    <para> </para>
    <para> </para>
    <para>What are the differences between Pre-emptive Scheduling Scheduler and Time Slicing Scheduler?</para>
    <para> </para>
    <para>In Pre-emptive scheduling, the highest priority task will keep getting time to execute until it goes to waiting state or dead state or a task with higher priority comes into queue for scheduling.</para>
    <para> </para>
    <para>In Time slicing scheduling, every task gets a predefined slice of time for execution, and then it goes to the pool of tasks ready for execution. The scheduler picks up the next task for execution, based on priority and various other factors.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>             Is it possible to call run()</para>
    <para>method instead of start() on a thread in Java​?</para>
    <para> </para>
    <para>Yes. We can call run() method of a thread. But it does not work as a separate thread. It will just work as a normal object in main thread and there will not be context-switching between the threads.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>How will you make a user thread into daemon thread if it has already started?</para>
    <para> </para>
    <para>No. We cannot make a user thread to daemon thread once it has already started.</para>
    <para> </para>
    <para>        If         we         do         it         by         calling         setDaemon(),         it         will         throw</para>
    <para>IllegalThreadStateException</para>
    <para> </para>
    <para>              Can we start a thread two times in Java?</para>
    <para> </para>
    <para>No. We can call start() method only once on a thread in Java. If we call it twice, it will give us exception.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> In what scenarios can we interrupt a thread?</para>
    <para> </para>
    <para>We can interrupt a thread if we want to wake it up from the sleep or wait state.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>              In Java, is it possible to lock an object for exclusive use by a thread?</para>
    <para> </para>
    <para>Yes. We can use synchronized block to lock an object. The locked object is inaccessible to any other thread. Only the thread that has locked it can access it.</para>
    <para> </para>
    <para> </para>
    <para>How notify() method is different from notifyAll() method?</para>
    <para> </para>
    <para>In Java, notify() method is used to unblock a specific thread that is in waiting stated. Whereas, notifyAll() method is used to unblock all the threads that are in waiting state.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>             What is a daemon thread in</para>
    <para>Java?</para>
    <para> </para>
    <para>A daemon thread in Java is a low priority thread that does not prevent the JVM from exiting when the program finishes. The thread keeps running. Garbage Collection is an example of daemon thread.</para>
    <para> </para>
    <para>265.              How can we make a regular thread Daemon thread in Java?</para>
    <para> </para>
    <para>We can call setDaemon(boolean) method to change a thread to daemon thread before the thread starts.</para>
    <para> </para>
    <para>How will you make a user thread into daemon thread if it has already started?</para>
    <para> </para>
    <para>No. We cannot make a user thread to daemon thread once it has already started. If we do it by calling setDaemon(), it will throw</para>
    <para>IllegalThreadStateException</para>
    <para> </para>
    <para>267.        Can we start a thread two times in Java?</para>
    <para> </para>
    <para>No. We can call start() method only once on a thread in Java. If we call it twice, it will give us exception.</para>
    <para> </para>
    <para>             What is a Shutdown hook in</para>
    <para>Java?</para>
    <para> </para>
    <para>The shutdown hook is a thread that is invoked implicitly by JVM just before the shut down. It can be used to clean up unused resources etc.</para>
    <para> </para>
    <para>We can use java.lang.Runtime.addShutdownHook(Thread hook) method to register a new virtual-machine shutdown hook.</para>
    <para> </para>
    <para> </para>
    <para>What is synchronization in Java?</para>
    <para> </para>
    <para>The concept of Synchronization in Java is used in Multi-threading programming.</para>
    <para> </para>
    <para>It is a feature in Java that helps in controlling the access of multiple threads to a shared resource.</para>
    <para> </para>
    <para>It is used to prevent Deadlock between multiple threads.</para>
    <para> </para>
    <para>              What is the purpose of</para>
    <para>Synchronized block in Java?</para>
    <para> </para>
    <para>Synchronized block has many uses in Java multi-threading environment. Some of the uses are:</para>
    <para> </para>
    <para>It can prevent thread interference</para>
    <para> </para>
    <para>It is also used to avoid memory inconsistency issues</para>
    <para> </para>
    <para>In general, scope of synchronized block is smaller than the scope of a method.</para>
    <para> </para>
    <para> What is static synchronization?</para>
    <para> </para>
    <para> </para>
    <para>We can make a static method as synchronized in Java. Adding synchronized keyword to a static method can do this.</para>
    <para> </para>
    <para>In static synchronization, the lock is on class not on object.</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>              What is a Deadlock situation?</para>
    <para> </para>
    <para>A Deadlock is a situation in which two or more threads are waiting on each other to release a resource. Each thread is waiting for a resource that is held by the other waiting thread.</para>
    <para> </para>
    <para>At times there is a circular wait when more than two threads are waiting on each other’s resources.</para>
    <para> </para>
    <para>What is the meaning of concurrency?</para>
    <para> </para>
    <para>Concurrency is the ability of a program to execute several programs simultaneously. This is achieved by distributing computations over multiple CPU cores of a machine or even over different machines within the same network.</para>
    <para> </para>
    <para>It can increase the speed of execution of the overall program in multi-processor or multi-core system.</para>
    <para> </para>
    <para>             What is the main difference between process and thread?</para>
    <para> </para>
    <para>As such both process and thread are independent sequences of execution.</para>
    <para> </para>
    <para>The main difference is that a thread runs in a shared memory space, where as a process runs in its own memory space.</para>
    <para> </para>
    <para>A process runs the execution in an environment provided by the operating system. A process has its own set of private resources (e.g. memory, open files, etc.).</para>
    <para> </para>
    <para>A thread lives within a process and shares the resources likememory, open files etc. with the other threads of the same process.</para>
    <para> </para>
    <para>This ability to share resources between different threads makes thread more suitable for tasks where performance is a significant factor.</para>
    <para> </para>
    <para>What is a process and thread in the context of Java?</para>
    <para> </para>
    <para>In Java, a process refers to the running of Java Virtual Machine (JVM). But a thread lives within a JVM and it can be created or stopped by the Java application at runtime.</para>
    <para> </para>
    <para>What is a Scheduler?</para>
    <para> </para>
    <para>A scheduler is a program that is the implementation of a scheduling algorithm to manage access of processes and threads to limited resource like CPU or an I/O channel.</para>
    <para> </para>
    <para>The goal of most scheduling algorithms is to provide load balancing for the available processes/threads and to guarantee that each process/thread will get a reasonable time frame to access the requested resource exclusively.</para>
    <para>What is the minimum number of Threads in a Java program?</para>
    <para> </para>
    <para>In a JVM, each Java program is executed within the main process that starts with java.exe. Therefore each Java application has at least one thread.</para>
    <para> </para>
    <para>What are the properties of a Java thread?</para>
    <para> </para>
    <para>Each Java thread has following properties:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Identifier: An identifier of type long that is unique within the JVM</para>
      </listitem>
      <listitem>
        <para>Name: A name of type String</para>
      </listitem>
      <listitem>
        <para>Priority: Priority of type int</para>
      </listitem>
      <listitem>
        <para>State: A state of type java.lang.Thread.State</para>
      </listitem>
      <listitem>
        <para>Group: A thread group the thread belongs to</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para>What are the different states of a Thread in Java?</para>
    <para> </para>
    <para>Following are the different states of a Thread in Java:</para>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem/>
    </orderedlist>
    <para> </para>
    <para> How will you set the priority of a thread in Java?</para>
    <para> </para>
    <para>The priority of a thread in Java can be set by using setPriority(int priority) method.</para>
    <para> </para>
    <para>We can use constant Thread.MAX_PRIORITY to set the maximum priority of a thread.</para>
    <para> </para>
    <para>We can use constant Thread.MIN_PRIORITY to set the minimum priority of a thread.</para>
    <para> </para>
    <para>Or we can use constant Thread.NORM_PRIORITY to set the default priority of a thread.</para>
    <para> </para>
    <para>               What is the purpose of Thread</para>
    <para>Groups in Java?</para>
    <para> </para>
    <para>In Java, every thread belongs to a group of threads.</para>
    <para> </para>
    <para>The JDK class java.lang.ThreadGroup provides methods to handle a whole group of Threads.</para>
    <para> </para>
    <para>With the help of these methods we can interrupt all threads of a group or set the maximum priority of all threads of a group.</para>
    <para> </para>
    <para>So a thread group is used for taking collective actions on a group of threads.</para>
    <para> </para>
    <para>Why we should not stop a thread by calling its stop() method?</para>
    <para> </para>
    <para>The stop() method in Thread class is a deprecated method. Its use is not recommended.</para>
    <para> </para>
    <para>When we call stop() method, the thread unlocks all monitors that it has acquired. If any locked object was in an inconsistent state, this state gets visible to all other threads.</para>
    <para> </para>
    <para>It can cause unexpected behavior when other threads work on this inconsistent object.</para>
    <para> </para>
    <para>So calling stop() method to stop a thread is not advisable.</para>
    <para> </para>
    <para> </para>
    <para>              How will you create a Thread in Java?</para>
    <para> </para>
    <para>There are two main ways to create a thread in Java.</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Extend Thread class: We can extend java.lang.Thread class and implement run() method. On calling start() method it will start a new thread.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Implement Runnable interface: We can implement java.lang.Runnable interface and pass the implemented object to the constructor of java.lang.Thread class. On calling start() it will start a new thread.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para>How can we stop a thread in the middle of execution in Java?</para>
    <para> </para>
    <para>We can use a volatile variable as an indicator to stop the thread.</para>
    <para> </para>
    <para>We can create a volatile reference pointing to the current thread. This reference can be set to null by other threads to flag that the current thread should stop execution.</para>
    <para> </para>
    <para>In following example threadStopper is the volatile reference that can be set as null in stopThread() method by other threads.</para>
    <para> </para>
    <para>Sample code is as follows:</para>
    <para> </para>
    <para>public static class MyThread extends Thread {</para>
    <para> </para>
    <para>    private volatile Thread threadStopper;</para>
    <para> </para>
    <para>    public void start() {         threadStopper = new Thread(this);</para>
    <para>        threadStopper.start();</para>
    <para>    }</para>
    <para> </para>
    <para>    public void stopThread() {</para>
    <para>        threadStopper = null;</para>
    <para>    }</para>
    <para> </para>
    <para>    public void run() {</para>
    <para>        Thread currThread = Thread.currentThread();</para>
    <para>        while(currThread == threadStopper) {             try {</para>
    <para>                Thread.sleep(100);</para>
    <para>            } catch (InterruptedException e) {</para>
    <para>            }</para>
    <para>        }</para>
    <para>    }</para>
    <para>}</para>
    <para> </para>
    <para>How do you access the current thread in a Java program?</para>
    <para> </para>
    <para>We can access the current thread in Java by calling the static method currentThread() of java.lang.Thread class.</para>
    <para> </para>
    <para>Sample code is as follows:</para>
    <para> </para>
    <para>public class MyThread {</para>
    <para> </para>
    <para>    public static void main(String[] args) {</para>
    <para>    // Get ID of Current Thread</para>
    <para>        long id = Thread.currentThread().getId();</para>
    <para> </para>
    <para>    // Get Name of Current Thread</para>
    <para>        String name = Thread.currentThread().getName();</para>
    <para>    }</para>
    <para>}</para>
    <para> </para>
    <para>             What is Busy waiting in Multithreading?</para>
    <para> </para>
    <para>Busy waiting is also known as busy-looping or spinning. It is a multi-threading technique in which a process repeatedly checks if a condition is true.</para>
    <para> </para>
    <para>For example, a process can keep checking if any keyboard input is available.</para>
    <para> </para>
    <para>In general, busy waiting is considered as Anti-pattern that wastes processor time, so it should be avoided.</para>
    <para> </para>
    <para>Sample code for busy waiting is as follows:</para>
    <para> </para>
    <para> </para>
    <para>Thread thread = new Thread(new Runnable() {</para>
    <para>  @Override   public void run() {     long timeToStop = System.currentTimeMillis() + 1000;     long currentTime = System.currentTimeMillis();</para>
    <para> </para>
    <para>    // Busy waiting    </para>
    <para>    while (timeToStop &gt; currentTime) {</para>
    <para>    currentTime = System.currentTimeMillis();</para>
    <para>    }</para>
    <para>  }</para>
    <para>});</para>
    <para> </para>
    <para>              How can we prevent busy waiting in Java?</para>
    <para> </para>
    <para>There is a simple way to prevent busy-waiting in Java. We can just put the current thread to sleep for given amount of time.</para>
    <para> </para>
    <para>It can be done by calling sleep() method of java.lang.Thread class. We can pass the number of milliseconds to sleep() method  as an argument.</para>
    <para> </para>
    <para>             Can we use Thread.sleep()</para>
    <para>method for real-time processing in Java?</para>
    <para> </para>
    <para>Java does not guarantee that Thread.sleep() will cause the thread to sleep for exactly N number of milliseconds. Sometime the thread can sleep for than N number of milliseconds.</para>
    <para> </para>
    <para>In real-time processing we need precise time period for which a thread should run or sleep.</para>
    <para> </para>
    <para>Therefore the invocation of Thread.sleep() method is not recommended for use in real-time processing.</para>
    <para> </para>
    <para>             Can we wake up a thread that has been put to sleep by using Thread.sleep() method?</para>
    <para> </para>
    <para>We can use interrupt() method of java.lang.Thread class to interrupt a thread that is in sleep state. It will get  InterruptedException to wake up from the sleep.</para>
    <para>Sample code is as follows:</para>
    <para> </para>
    <para>public class ThreadInterrupt implements Runnable {</para>
    <para>  public void run() {</para>
    <para>  try {</para>
    <para>      Thread.sleep(Long.MAX_VALUE);</para>
    <para>    } catch (InterruptedException e) {</para>
    <para>      SOP(“Interrupted by exception!");</para>
    <para>    }   }</para>
    <para>  public static void main(String[] args) throws InterruptedException</para>
    <para>{</para>
    <para>    Thread myThread = new Thread(new ThreadInterrupt(),</para>
    <para>“myThread");     myThread.start();</para>
    <para>    SOP(“Sleeping in main thread for 10 seconds”);</para>
    <para> </para>
    <para>    Thread.sleep(10000);</para>
    <para>    SOP(“Interrupting myThread");</para>
    <para> </para>
    <para>    myThread.interrupt();</para>
    <para>  }</para>
    <para>}</para>
    <para> </para>
    <para>              What are the two ways to</para>
    <para>check if a Thread has been interrupted?</para>
    <para> </para>
    <para>These are the two ways to check for thread interruption:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>In Java, a Thread can call Thread.interrupted() method to check if it has been interrupted or not.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>The other option is to call isInterrupted() method of Thread class to check if it has been interrupted or not.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para> How can we make sure that Parent thread waits for termination of Child thread?</para>
    <para> </para>
    <para>We can use join() method for this purpose. On calling join() method, current thread waits for the child thread to which it joins to finish.</para>
    <para> </para>
    <para>Sample code is as follows:</para>
    <para> </para>
    <para>Thread myThread = new Thread(new Runnable() {</para>
    <para>  public void run() {</para>
    <para>    }</para>
    <para>});</para>
    <para> </para>
    <para>myThread.start(); // Join on myThread</para>
    <para>myThread.join();</para>
    <para> </para>
    <para> </para>
    <para> </para>
    <para>              How will you handle</para>
    <para>InterruptedException in Java?</para>
    <para> </para>
    <para> </para>
    <para>In Java we can get InterruptedException from sleep() or join() methods. Throwing InterruptedException is way to inform that another thread has interrupted this thread.</para>
    <para> </para>
    <para>In general, the purpose of Interrupt is to ask current thread to stop its current execution and finish unexpectedly.</para>
    <para> </para>
    <para>Therefore ignoring this exception by catching it and only logging it to the console or some log file is not the recommended approach.</para>
    <para> </para>
    <para>The run() method of the Runnable interface does not allow that throwing any exceptions. So we cannot re-throw</para>
    <para>InterruptedException.</para>
    <para> </para>
    <para>Therefore the correct way to handle this exception is that run() method should check and handle this exception by itself and take appropriate action.</para>
    <para> </para>
    <para> </para>
    <para>Which intrinsic lock is acquired by a synchronized method in Java?</para>
    <para> </para>
    <para>When we mark a method as synchronized and then call this method, then this method will first acquire the intrinsic lock of the object in which that method is mentioned.</para>
    <para> </para>
    <para>Once the synchronized method returns, it releases the lock.</para>
    <para> </para>
    <para>In case the synchronized method throws an exception, the intrinsic lock will be released.</para>
    <para> </para>
    <para> </para>
    <para>Sample code equivalent to a synchronized method is:</para>
    <para> </para>
    <para>public void myMethod() {   synchronized(this) {</para>
    <para>  }</para>
    <para>}</para>
    <para>             Can we mark a constructor as synchronized in Java?</para>
    <para> </para>
    <para>No. We cannot mark a constructor as synchronized.</para>
    <para> </para>
    <para>This will lead to compiler error.</para>
    <para> </para>
    <para>The reasoning behind this is that, in this case, only the constructing thread would have access to the object being constructed.</para>
    <para> </para>
    <para>295.        Can we use primitive values for intrinsic locks?</para>
    <para> </para>
    <para>No. Java does not allow primitive values to be used for intrinsic locks.</para>
    <para> </para>
    <para>Do we have re-entrant property in intrinsic locks?</para>
    <para> </para>
    <para>Yes. An intrinsic lock can be accessed by the same thread multiple times. So an Intrinsic lock is re-entrant.</para>
    <para> </para>
    <para>If it is not allowed then the code that acquires a lock would have to avoid acquiring the lock that it has already acquired.</para>
    <para> </para>
    <para>What is an atomic operation?</para>
    <para> </para>
    <para>An atomic operation is an operation that completes in a single step relative to other threads.</para>
    <para> </para>
    <para>An Atomic operation is either executed completely or not at all.</para>
    <para> </para>
    <para>There is no halfway mark in Atomic operation.</para>
    <para> </para>
    <para>             Can we consider the statement i++ as an atomic operation in Java?</para>
    <para> </para>
    <para>No. The statement i++ is not an Atomic operation. It has more than one operation.</para>
    <para> </para>
    <para>First JVM loads the current value of i in memory. Then it increments it. Finally it stores the new value back into variable i.</para>
    <para> </para>
    <para>The current thread that executes this operation may be interrupted between any of the above-mentioned three steps. Therefore it is not an atomic operation.</para>
    <para> </para>
    <para>What are the Atomic operations in Java?</para>
    <para> </para>
    <para>Java language provides some basic Atomic operations. These operations can be used to make sure that concurrent threads always see the same value.</para>
    <para> </para>
    <para>Some of these Atomic operations are:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Read operations on reference variables and primitive variables (except long and double)</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Write operations on reference variables and primitive variables (except long and double)</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Read operations on all variables declared as volatile</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Write operations on all variables declared as volatile</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>              Can you check if following code is thread-safe?</para>
    <para> </para>
    <para>public class SingletonDoubleCheck {</para>
    <para>private SingletonDoubleCheck instance = null;</para>
    <para> </para>
    <para>public SingletonDoubleCheck getInstance() { if (instance == null) { synchronized (SingletonDoubleCheck.class) { if (instance == null) { instance = new SingletonDoubleCheck();</para>
    <para>}</para>
    <para>}</para>
    <para>}</para>
    <para>return instance;</para>
    <para>}</para>
    <para>}</para>
    <para> </para>
    <para>The above-mentioned code is for creating a Singleton class. But this code is not thread-safe.</para>
    <para> </para>
    <para>In this we check the value of instance second time in the synchronized block. But the JIT compiler can rearrange the Bytecode in such a way that the reference to SingletonDoubleCheck instance will be set before the execution of constructor.</para>
    <para> </para>
    <para>Due to this the method getInstance() will return an object that may not have been initialized properly.</para>
    <para> </para>
    <para>We can use the keyword volatile for instance to make this threadsafe code.</para>
    <para> </para>
    <para>Any variables that is marked as volatile will be visible to other threads only after the completion of the constructor of the object.</para>
    <para> </para>
    <para> What are the minimum requirements for a Deadlock situation in a program?</para>
    <para> </para>
    <para>For a deadlock to occur following are the minimum requirements:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Mutual exclusion: There has to be a resource that can be accessed by only one thread at any point of time.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Resource holding: One thread locks one resource and holds it, and at the same time it tries to acquire lock on another mutually exclusive resource.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>No preemption: There is no pre-emption mechanism by which resource held by a thread can be freed after a specific period of time.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Circular wait: There can be a scenario in which two or more threads lock one resource each and they wait for each other’s resource to get free. This causes circular wait among threads for same set of resources.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para>              How can we prevent a</para>
    <para>Deadlock?</para>
    <para> </para>
    <para>To prevent a Deadlock from occurring at least one requirement for a deadlock has to be removed:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Mutual exclusion: We can use optimistic locking to prevent mutual exclusion among resources.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Resource holding: A thread has to release all its exclusive locks if it does not succeed in acquiring all exclusive locks for resources required.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>No preemption: We can use timeout period for an exclusive lock to get free after a given amount of time.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Circular wait: We can check and ensure that circular wait does not occur, when all exclusive locks have been acquired by all the threads in the same sequence.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para>How can we detect a Deadlock situation?</para>
    <para> </para>
    <para> </para>
    <para>We can use ThreadMXBean.findDeadlockedThreads() method to detect deadlocks in Java program. This bean comes with JDK:</para>
    <para> </para>
    <para> </para>
    <para>Sample code is as follows:</para>
    <para> </para>
    <para>ThreadMXBean bean = ManagementFactory.getThreadMXBean(); long[] threadIds = bean.findDeadlockedThreads(); // It will return null for no deadlock if (threadIds != null) {</para>
    <para>    ThreadInfo[] infos = bean.getThreadInfo(threadIds);</para>
    <para> </para>
    <para>    for (ThreadInfo info : infos) {</para>
    <para>        StackTraceElement[] stack = info.getStackTrace();         // Log or store stack trace information.</para>
    <para>    }</para>
    <para>}</para>
    <para>             What is a Livelock?</para>
    <para> </para>
    <para>Livelock is a scenario in which two or more block each other by responding to an action caused by another thread.</para>
    <para> </para>
    <para>In a deadlock situation two or more threads wait in one specific state.</para>
    <para> </para>
    <para>In a Livelock scenario, two more threads change their state in such a way that it prevents progress on their regular work.</para>
    <para> </para>
    <para>E.g. Consider scenario in which two threads try to acquire two locks. They release a lock that they have acquired, when they cannot acquire the second lock.</para>
    <para> </para>
    <para>In a Livelock situation, both threads concurrently try to acquire the locks. Only one thread would succeed, the second thread may succeed in acquiring the second lock.</para>
    <para> </para>
    <para>Now both threads hold two different locks. And both threads want to have both locks. So they release their lock and try again from the beginning. This situation keeps repeating multiple times..</para>
    <para> </para>
    <para>What is Thread starvation?</para>
    <para> </para>
    <para>In a priority based scheduling, Threads with lower priority get lesser time for execution than higher priority threads.</para>
    <para> </para>
    <para>If a lower priority thread performs a long running computation, it may happen that this thread does not get enough time to finish its computations just in time. In such a scenario, the tread with lower priority would starve. It will remain away from the threads with higher priority.</para>
    <para> </para>
    <para>How can a synchronized block cause Thread starvation in Java?</para>
    <para> </para>
    <para>It is not defined for synchronization that which thread will enter a synchronized block. It may happen that if many threads are waiting for the entry to a synchronized block, some threads may have to wait longer than other threads.</para>
    <para> </para>
    <para>Hence these threads with lower priority will not get enough time to finish their work in time.</para>
    <para> </para>
    <para>What is a Race condition?</para>
    <para> </para>
    <para>A race condition is an unwanted situation in which a program attempts to perform two or more operations at the same time, but because of the logic of the program, the operations have to be performed in proper sequence to run the program correctly.</para>
    <para> </para>
    <para>Since it is an undesirable behavior, it is considered as a bug in code.</para>
    <para> </para>
    <para>Most of the time race condition occurs in “check then act” scenario. Both threads check and act on same value. But one of the threads acts in between check and act. See this example to understand race condition.</para>
    <para> </para>
    <para> </para>
    <para>if (x == 3) // Check</para>
    <para>{</para>
    <para>   y = x * 5; // Act</para>
    <para> </para>
    <para>   // If another thread changes x</para>
    <para>   // between "if (x == 3)” and "y = x * 5”,    // then y will not be equal to 15.</para>
    <para>}</para>
    <para> </para>
    <para>What is a Fair lock in multithreading?</para>
    <para> </para>
    <para>In Java there is a class ReentrantLock that is used for implementing Fair lock. This class accepts an optional parameter fairness. When fairness is set to true, the RenentrantLock will give access to the longest waiting thread.</para>
    <para> </para>
    <para>The most popular use of Fair lock is in avoiding thread starvation. Since longest waiting threads are always given priority in case of contention, no thread can starve.</para>
    <para> </para>
    <para>Downside of Fair lock is the low throughput of the program. Since low priority or slow threads are getting locks multiple time, it leads to slower execution of a program.</para>
    <para> </para>
    <para>The only exception to a Fair lock is tryLock() method of ReentrantLock. This method does not honor the value of fairness parameter.</para>
    <para> </para>
    <para>Which two methods of Object class can be used to implement a Producer Consumer scenario?</para>
    <para> </para>
    <para>In a Producer Consumer scenario, one thread is a Producer and another thread is a Consumer.</para>
    <para> </para>
    <para>For this scenario to start working, a Consumer has to know when the Producer has produced. In Object class, there is a wait() method. A Consumer calls wait method to wait on Producer. The Producer used notify() method of Object class to inform Consumer that it has produced.</para>
    <para> </para>
    <para>In this way the processor time between produce and consume operations is freed due to the use of wait() and notify() methods.</para>
    <para> </para>
    <para> How JVM determines which thread should wake up on notify()?</para>
    <para> </para>
    <para>If multiple threads are waiting on an object’s monitor, JVM awakens one of them. As per Java specification the choice of this thread is arbitrary and it is at the discretion of the implementation. So there is no guarantee of rule that a specific thread will be awakened by JVM on notify() method call.</para>
    <para> </para>
    <para>  Check if following code is threadsafe for retrieving an integer value from a Queue?</para>
    <para> </para>
    <para>public class QueueCheck {</para>
    <para>Queue queue;</para>
    <para> </para>
    <para>public Integer getNextInt() { Integer retVal = null; synchronized (queue) { try { while (queue.isEmpty()) { queue.wait();</para>
    <para>}</para>
    <para>} catch (InterruptedException e) { e.printStackTrace();</para>
    <para>}</para>
    <para>}</para>
    <para>synchronized (queue) { retVal = queue.poll(); if (retVal == null) {</para>
    <para>System.err.println("retVal is null");</para>
    <para>throw new IllegalStateException();                                          }</para>
    <para>}</para>
    <para>return retVal;</para>
    <para>}</para>
    <para>}</para>
    <para> </para>
    <para>In the above code Queue is used as object monitor to handle concurrency issues. But it may not behave correctly in a multithreading scenario.</para>
    <para> </para>
    <para>There are two separate synchronized blocks in above code. In case two threads are woken up simultaneously by another thread, both</para>
    <para>threads will enter one after in the second synchronized block.</para>
    <para> </para>
    <para>Only one of the two threads will get new value from the queue and make it empty. The second thread will poll on an empty queue and it will not get any non-null return value.</para>
    <para> </para>
    <para> </para>
    <para> How can we check if a thread has a monitor lock on a given object?</para>
    <para> </para>
    <para>In Java, Thread class has a static method holdsLock(Object objToCheck) to check whether thread has a lock on objToLock object. </para>
    <para> </para>
    <para>This method will return true if current thread holds the lock on the objToLock object that was passed as an argument to this method.</para>
    <para> </para>
    <para>What is the use of yield() method in Thread class?</para>
    <para> </para>
    <para>The yield() method of Thread class is used to give a hint to scheduler that the current thread wants to free the processor.</para>
    <para> </para>
    <para>The scheduler can either use this hint or just ignore this hint. Since the scheduler behavior is not guaranteed, it may happen that the current thread again gets the processor time.</para>
    <para> </para>
    <para>It can be used for debugging or testing purposes. But there is rarely any concrete use of this method.</para>
    <para> </para>
    <para>               What is an important point to</para>
    <para>consider while passing an object from one thread to another thread?</para>
    <para> </para>
    <para>This is a multi-threading scenario. In a multi-threading scenario, the most important point is to check whether two threads can update same object at the same time.</para>
    <para> </para>
    <para>If it is possible for two threads to update the same object at the same time, it can cause issues like race condition.</para>
    <para> </para>
    <para>So it is recommended to make the object Immutable. This will help in avoiding any concurrency issues on this object.</para>
    <para> </para>
    <para> </para>
    <para>What are the rules for creating Immutable Objects?</para>
    <para> </para>
    <para>As per Java specification, following are the rules for creating an Immutable object:</para>
    <para> </para>
    <para>Do not provide "setter" methods that modify fields or objects referred to by fields.</para>
    <para> </para>
    <para>Make all fields final and private.</para>
    <para> </para>
    <para>Do not allow subclasses to override methods. The simplest way to do this is to declare the class as final. A more sophisticated approach is to make the constructor private and construct instances in factory methods.</para>
    <para> </para>
    <para>If the instance fields include references to mutable objects, do not allow those objects to be changed.</para>
    <para> </para>
    <para>Do not provide methods that modify the mutable objects.</para>
    <para> </para>
    <para>Do not share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.</para>
    <para> </para>
    <para>What is the use of ThreadLocal class?</para>
    <para> </para>
    <para>ThreadLocal class provides thread-local variables. Each thread accesses only its own local variables. It has its own copy of the variable.</para>
    <para> </para>
    <para>By using ThreadLocal, if thread X stores a variable with value x and another thread Y stores same variable with the value y, then X</para>
    <para>gets x from its ThreadLocal instance and Y gets y from its ThreadLocal instance.</para>
    <para> </para>
    <para>Typically, ThreadLocal instances are private static fields that are associated with the state of a thread.</para>
    <para> </para>
    <para>What are the scenarios suitable for using ThreadLocal class?</para>
    <para> </para>
    <para>We can use instance of ThreadLocal class to transport information within an application.</para>
    <para> </para>
    <para>One use case is to transport security or login information within an instance of ThreadLocal so that every method can access it.</para>
    <para> </para>
    <para>Another use case is to transport transaction information across an application, without using the method-to-method communication.</para>
    <para> </para>
    <para>How will you improve the performance of an application by multi-threading?</para>
    <para> </para>
    <para>In an environment with more than one CPU, we can parallelize the computation tasks on multiple CPUs. This leads to parallel processing of a bigger task that takes lesser time due to multiple threads dividing the work among themselves.</para>
    <para> </para>
    <para>One example is that if we have to process 1000 data files and calculate the sum of numbers in each file. If each file takes 5 minutes, then 1000 files will take 5000 minutes for processing.</para>
    <para> </para>
    <para>But by using multi-threading we can process these files in 10 parallel threads. So each thread will take 100 files each. Since now work is happening in 10 parallel threads, the time taken will be around 500 minutes.</para>
    <para> </para>
    <para>What is scalability in a Software program?</para>
    <para> </para>
    <para>Scalability is the capability of a program to handle growing amount of work or its potential to be enlarged in order to accommodate growth.</para>
    <para> </para>
    <para>A program is considered scalable, if it is suitable to handle a large amount of input data or a large number of users or a large number of nodes.</para>
    <para> </para>
    <para>When we say a program does not scale, it means that program fails on increasing the size of task.</para>
    <para> </para>
    <para>              How will you calculate the</para>
    <para>maximum speed up of an application by using multiple processors?</para>
    <para> </para>
    <para>Amdahl’s law gives the theoretical speedup in latency of the execution of a task at fixed workload.</para>
    <para> </para>
    <para>It gives the formula to compute the theoretical maximum speed up that can be achieved by providing multiple processors to an application.</para>
    <para> </para>
    <para>If S is the theoretical speedup then the formula is:</para>
    <para>S(n) = 1 / (B + (1-B)/n)</para>
    <para> </para>
    <para>where n is the number of processors</para>
    <para>B is the fraction of the program that cannot be executed in parallel.</para>
    <para> </para>
    <para>When n converges against infinity, the term (1-B)/n converges against zero. Therefore, the formula can be reduced in this special case to 1/B.</para>
    <para> </para>
    <para>In general, the theoretical maximum speedup behaves in inverse proportion to the fraction that has to be executed serially. This means the lower this fraction is, the more theoretical speedup can be achieved.</para>
    <para> </para>
    <para>What is Lock contention in multithreading?</para>
    <para> </para>
    <para>Lock contention is the situation when one thread is waiting for a lock/object that being held by another thread. The waiting thread cannot use this object until the other thread releases the lock on that object.</para>
    <para> </para>
    <para>It is also known as Thread contention.</para>
    <para> </para>
    <para>Ideally locks reduce the thread contention. Without locks, multiple threads can operate on same object and cause undesirable behavior. If locking is implemented correctly it reduces the occurrence of contention between multiple threads.</para>
    <para> </para>
    <para>              What are the techniques to reduce Lock contention?</para>
    <para> </para>
    <para>There are following main techniques to reduce Lock contention:</para>
    <para> </para>
    <orderedlist>
      <listitem>
        <para>Reduce the scope of lock.</para>
      </listitem>
      <listitem>
        <para>Reduce object pooling.</para>
      </listitem>
      <listitem>
        <para>Reduce the number of times a certain lock can be acquired.</para>
      </listitem>
      <listitem>
        <para>Avoid synchronization at unnecessary places.</para>
      </listitem>
      <listitem>
        <para>Implement hardware supported Optimistic locking in place of synchronization.</para>
      </listitem>
    </orderedlist>
    <para> </para>
    <para> </para>
    <para>What technique can be used in following code to reduce Lock contention?</para>
    <para> </para>
    <para>synchronized (map) {</para>
    <para>Random r = new Random();</para>
    <para>Integer value = Integer.valueOf(42); String key = r.nextString(5);</para>
    <para>map.put(key, value);</para>
    <para>}</para>
    <para> </para>
    <para>The code uses Random() to get a random string and it also used Integer to convert 42 in an object. Since these lines of code are specific to this thread, these can be moved out of Synchronization block.</para>
    <para> </para>
    <para>Random r = new Random();</para>
    <para>Integer value = Integer.valueOf(42);</para>
    <para>String key = r.nextString(5);</para>
    <para> </para>
    <para>synchronized (map) { map.put(key, value);</para>
    <para>}</para>
    <para> </para>
    <para>             What is Lock splitting technique?</para>
    <para> </para>
    <para>Lock splitting is a technique to reduce Lock contention in multithreading. It is applicable in scenario when one lock is used to synchronize access to different aspects of the same application.</para>
    <para> </para>
    <para>Sometimes we put one lock to protect the whole array. There can be multiple threads trying to get the lock for same array. This single lock on array can cause Lock contention among threads. To resolve this we can give one lock to each element of the array. Or we can use modulus function to assign different locks to a small group of array elements. In this way we can reduced the chance of Lock contention. This is Lock splitting technique.</para>
    <para> </para>
    <para>Which technique is used in ReadWriteLock class for reducing Lock contention?</para>
    <para> </para>
    <para>ReadWriteLock uses two locks. One lock for read-only operations, another lock for write operations.</para>
    <para> </para>
    <para>Its implementation is based on the premise that concurrent threads do not need a lock when they want to read a value while no other thread is trying to write.</para>
    <para> </para>
    <para>In this implementation, read-only lock can be obtained by multiple threads. And the implementation guarantees that all read operation will see only the latest updated value as soon as the write lock is released.</para>
    <para> </para>
    <para>What is Lock striping?</para>
    <para> </para>
    <para>In Lock splitting we use different locks for different parts of the application. In Lock striping we use multiple locks to protect different parts of the same data structure.</para>
    <para> </para>
    <para>ConcurrentHashMap class of Java internally uses different buckets to store its values. Each bucket is chosen based on the value of key. ConcurrentHashMap uses different locks to guard different buckets. When one thread that tries to access a hash bucket, it can acquire the lock for that bucket. While another thread can simultaneously acquire lock for another bucket and access it. In a synchronized version of HashMap, the whole map is has one lock.</para>
    <para> </para>
    <para>Lock striping technique gives better performance than Synchronizing the whole data structure.</para>
    <para> </para>
    <para>What is a CAS operation?</para>
    <para> </para>
    <para>CAS is also known a Compare-And-Swap operation.</para>
    <para> </para>
    <para>In a CAS operation, the processor provides a separate instruction that can update the value of a register only if the provided value is equal to the current value.</para>
    <para> </para>
    <para>CAS operation can be used as an alternate to synchronization.</para>
    <para> </para>
    <para>Let say thread T1 can update a value by passing its current value and the new value to be updated to the CAS operation. In case another thread T2 has updated the current value of previous thread, the previous thread T1’s current value is not equal to the current value of T2. Hence the update operation fails.</para>
    <para> </para>
    <para>In this case, thread T1 will read the current value again and try to update it.</para>
    <para> </para>
    <para>This is an example of optimistic locking.</para>
    <para> </para>
    <para>Which Java classes use CAS operation?</para>
    <para> </para>
    <para>Java classes like AtomicInteger or AtomicBoolean internally use CAS operations to support multi-threading.</para>
    <para> </para>
    <para>These classes are in package java.util.concurrent.atomic.</para>
    <para> </para>
    <para> </para>
    <para>Is it always possible to improve performance by object pooling in a multi-threading application?</para>
    <para> </para>
    <para>By using Object pools in an application we limit the number of new objects to be created for a class. In a single thread operation, it can improve the performance by reusing an already created object from a pool.</para>
    <para> </para>
    <para>In a multi-threading application an object pool has to provide synchronized access to multiple threads. Due to this only one thread can access the pool at a time. Also there is additional cost due to Lock contention on pool. These additional costs can outweigh the cost saved by reuse of an object from the pool.</para>
    <para> </para>
    <para>Therefore using an Object pool may not always improve the performance in a multi-threading application.</para>
    <para> </para>
    <para>How can techniques used for performance improvement in a single thread application may degrade the performance in a multi-threading application?</para>
    <para> </para>
    <para>In a single thread applications we can use Object pool for performance optimization. Where as in multi-threading environment, it may not be a good idea to use an Object pool. Increased overhead of synchronization and lock contention can degrade the performance gained by using Object pool in a multi-threading application.</para>
    <para> </para>
    <para>Another example is the implementation in which a List keeps a separate variable to hold the number of elements. This technique is useful in single thread application where size() method can return the value from this variable, without the need to count all the elements of list.</para>
    <para> </para>
    <para>But in a multi-threading application, this separate variable can rather degrade the performance. This variable has to be access controlled by a lock since multiple concurrent threads can insert an element in a list. The additional cost of lock on this variable can outweigh the benefit gained by it in a multi-threading application.</para>
    <para> </para>
    <para> </para>
    <para> What is the relation between Executor and ExecutorService interface?</para>
    <para> </para>
    <para>Executor interface  has only execute(Runnable) method. The implementing class of this interface has to execute the given Runnable instance passed to execute() method at some time in the future.</para>
    <para> </para>
    <para>ExecutorService interface extends Executor interface. It provides additional methods like- invokeAny(), invokeAll(), shutdown(), awaitTermination(). These method provide the ability to shutdown the thread so that further requests can be rejected. Also it provides ability to invoke a collection of Callable tasks.</para>
    <para> </para>
    <para>              What will happen on calling</para>
    <para>submit() method of an ExecutorService instance whose queue is already full?</para>
    <para> </para>
    <para>The         implementation         of         ExecutorService         will         throw RejectedExecutionException, when its queue is already full and a new task is submitted by calling submit() method.</para>
    <para> </para>
    <para>What is a</para>
    <para>ScheduledExecutorService?</para>
    <para> </para>
    <para>ScheduledExecutorService interface extends the interface ExecutorService. It provides various schedule() methods that can be used to submit new tasks to be executed at a given point of time.</para>
    <para> </para>
    <para>One of the schedule() method provides the ability to schedule a oneshot task that can be executed after given delay.</para>
    <para> </para>
    <para>Another version of schedule() method provides the ability to execute ScheduleFuture after a given amount of delay.</para>
    <para> </para>
    <para>In addition there are scheduleAtFixedRate() and scheduleWithFixedDelay() methods that can execute an action at a periodic interval of time.</para>
    <para> </para>
    <para>             How will you create a Thread pool in Java?</para>
    <para> </para>
    <para>In         Java,         Executors         framework         provides         a         method newFixedThreadPool(int nThreads) that can be used to create a Thread pool with a fixed number of threads.</para>
    <para> </para>
    <para>Sample code is as follows:</para>
    <para> </para>
    <para>public static void main(String[] args) throws InterruptedException,</para>
    <para>ExecutionException</para>
    <para>{</para>
    <para>ExecutorService myService = Executors.newFixedThreadPool(5);</para>
    <para>Future&lt;Integer&gt;[] futureList = new Future[5]; for (int i = 0; i &lt; futureList.length; i++) { futureList[i] = myService.submit(new MyCallable());</para>
    <para>}</para>
    <para>for (int i = 0; i &lt; futureList.length; i++) { Integer retVal = futureList[i].get(); println(retVal);</para>
    <para>}</para>
    <para>myService.shutdown();</para>
    <para>}</para>
    <para> </para>
    <para>What is the main difference between Runnable and Callable interface?</para>
    <para> </para>
    <para>Runnable interface defines run() method that does not return any value.</para>
    <para> </para>
    <para>Callable interface allows call() method to return a value to its caller. A Callable interface can also throw an exception in case of an error. Also Callable is a newer addition to Java since version 1.5.</para>
    <para> </para>
    <para> </para>
    <para>What are the uses of Future interface in Java?</para>
    <para> </para>
    <para>We can use Future interface to represent the result of an asynchronous computation.</para>
    <para> </para>
    <para>These are the operations whose result is not immediately available.</para>
    <para> </para>
    <para>Therefore Future interface provides isDone() method to check if the asynchronous computation has finished or not.</para>
    <para> </para>
    <para>We can also check if the task was cancelled by calling isCancelled() method.</para>
    <para> </para>
    <para>Future also provides cancel() method to attempt the cancellation of a task.</para>
    <para> </para>
    <para>What is the difference in concurrency in HashMap and in Hashtable?</para>
    <para> </para>
    <para>In a Hashtable class all methods are synchronized.</para>
    <para> </para>
    <para>In a HashMap implementation all the methods are not synchronized.</para>
    <para> </para>
    <para>Therefore Hashtable is a thread-safe collection. HashMap is not a thread-safe collection.</para>
    <para> </para>
    <para>In a multi-threading it is not advisable to use regular HashMap. We can use ConcurrentHashMap class in multi-threading applications.</para>
    <para> </para>
    <para>How will you create synchronized instance of List or Map Collection?</para>
    <para> </para>
    <para>In Java, Collections class provides methods to synchronize any collection.</para>
    <para> </para>
    <para>It also provides synchronizedList(List) and synchronizedMap(Map) methods that can be used to convert a List or Map to a synchronized instance.</para>
    <para> </para>
    <para>What is a Semaphore in Java?</para>
    <para> </para>
    <para>Semaphore class in Java is used to implement a counting semaphore. It is used to restrict the number of threads that can access a physical or logical resource.</para>
    <para> </para>
    <para>A Semaphore maintains a set of permits that should be acquired by competing threads.</para>
    <para> </para>
    <para>We can also use it to control how many threads can access the critical section of a program or a resource concurrently.</para>
    <para> </para>
    <para>The first argument in Semaphore constructor is the total number of permits available. Each invocation of acquire() method tries to obtain one of the available permits.</para>
    <para> </para>
    <para>The acquire() method is used to acquire a permit from the semaphore. If we pass number of permits required to acquire() method, then it blocks the thread until that number of permits are available.</para>
    <para> </para>
    <para>Once a thread has finished its work, we can use release() method to release the permits.</para>
    <para> </para>
    <para>What is a CountDownLatch in Java?</para>
    <para> </para>
    <para>CountDownLatch class helps in implementing synchronization in Java. It is used to implement the scenarios in which one or more threads have to wait until other threads have reached the same state such that all thread can start.</para>
    <para> </para>
    <para>There is a synchronized counter that is decremented until it reaches the value zero. Once it reaches zero, it means that all waiting threads can proceed now.</para>
    <para> </para>
    <para>It is a versatile tool that can be used for other Synchronization scenarios as well. It can also work as on/off latch or gate. All threads invoking await() method wait at the gate until it is opened by a thread invoking countdown() method.</para>
    <para> </para>
    <para> </para>
    <para>               What is the difference between</para>
    <para>CountDownLatch and CyclicBarrier?</para>
    <para> </para>
    <para>CyclicBarrier takes an optional Runnable task that is run once the common barrier condition is achieved.</para>
    <para> </para>
    <para>CountDownLatch is used in simple use cases where a simple start stop is required. A CyclicBarrier is useful in complex scenarios where more coordination is required. E.g. MapReduce algorithm implementation.</para>
    <para> </para>
    <para>CyclicBarrier resets the internal value to the initial value once the value reaches zero. CyclicBarrier can be used to implement the scenarios in which threads have to wait for each other multiple times.</para>
    <para> </para>
    <para>What are the scenarios suitable for using Fork/Join framework?</para>
    <para> </para>
    <para>ForkJoinPool class is in the center of Fork/Join framework. It is a thread pool that can execute instances of ForkJoinTask.</para>
    <para> </para>
    <para>ForkJoinTask class provides the fork() and join() methods. The fork() method is used to start the asynchronous execution of a task. The join() method is used to await the result of the computation.</para>
    <para> </para>
    <para>Therefore, divide-and-conquer algorithms can be easily implemented with Fork/Join framework.</para>
    <para> </para>
    <para> </para>
    <para>What is the difference between RecursiveTask and RecursiveAction class?</para>
    <para> </para>
    <para>RecursiveAction class has compute() method that does not have to return a value.</para>
    <para> </para>
    <para>RecursiveAction can be used when the action has to directly operate on a Data structure. It does not need to return any computed value.</para>
    <para> </para>
    <para>In RecursiveTask class has compute() method that always returns a value.</para>
    <para> </para>
    <para>Both RecursiveTask and RecursiveAction classes are used in ForkJoinTask implementations.</para>
    <para> </para>
    <para>In Java 8, can we process stream operations with a Thread pool?</para>
    <para> </para>
    <para>In Java 8, Collections provide parallelStream() method to create a stream that can be processed by a Thread pool.</para>
    <para> </para>
    <para>We can also call the intermediate method parallel() on a given stream to convert it into a sequential stream of parallel tasks.</para>
    <para> </para>
    <para>What are the scenarios to use parallel stream  in Java 8?</para>
    <para> </para>
    <para>A parallel stream in Java 8 has a much higher overhead compared to a sequential one.</para>
    <para> </para>
    <para>It takes a significant amount of time to coordinate the threads.</para>
    <para> </para>
    <para>We can use parallel stream in following scenarios:</para>
    <para> </para>
    <para>When there are a large number of items to process and the processing of each item takes time and is parallelizable. When there is a performance problem in the sequential processing. When current implementation is not already running in a multithread environment. If there is already a multi-threading environment, adding parallel stream can degrade the performance.</para>
    <para> </para>
    <para>How Stack and Heap work in Java multi-threading environment?</para>
    <para> </para>
    <para>In Java, Stack and heap are memory areas available to an application. Every thread has its own stack. It is used to store local variables, method parameters and call stack.</para>
    <para> </para>
    <para>Local variables stored in Stack of one Thread are not visible to another Thread.</para>
    <para> </para>
    <para>Where as, Heap is a common memory area in JVM. Heap is shared by all threads. All objects are created inside heap.</para>
    <para> </para>
    <para>To improve performance thread can cache the values from heap into their stack. This can create problem if the same variable is modified by more than one thread.</para>
    <para> </para>
    <para>In such a scenario we should used volatile keyword to mark a variable volatile. For a volatile variable the thread always reads the value from main memory.</para>
    <para> </para>
    <para>How can we take Thread dump in Java?</para>
    <para> </para>
    <para>The steps to take Thread dump of Java process depends on the operating system.</para>
    <para> </para>
    <para>On taking Thread dump, Java writes the state of all threads in log files or standard error console.</para>
    <para> </para>
    <para>We can press Ctrl + Break key together to take thread dump in Windows.</para>
    <para>We can execute kill -3 command for taking Thread dump on Linux. Another option to take Thread dump is jstack tool. We can pass process id of java process to this tool for taking Thread dump.</para>
    <para> </para>
    <para> </para>
    <para>This is the simple one, -Xss parameter is used to control stack size of Thread in Java. You can see this list of JVM options to learn more about this parameter.</para>
    <para> </para>
    <para>Which parameter can be used to control stack size of a thread in Java?</para>
    <para> </para>
    <para>We use –Xss parameter to control the stack size of a thread in Java.</para>
    <para> </para>
    <para>If we set it as 1 MB, then every thread will get 1MB of stack size.</para>
    <para> </para>
    <para>There are two threads T1 and T2? How will you ensure that these threads run in sequence T1, T2 in Java?</para>
    <para> </para>
    <para>In Java there are multiple ways to execute threads in a sequence.</para>
    <para> </para>
    <para>One of the simplest way for sequencing is join() method of Thread class.</para>
    <para> </para>
    <para>We can call join() method to start a thread when another thread has finished.</para>
    <para> </para>
    <para>We start with the last thread to execute first. And make this thread join on the next thread.</para>
    <para> </para>
    <para>In this case we start thread T2 first. And then call T1.join() so that thread T2 waits for thread T1 to finish execution.</para>
    <para> </para>
    <para>Once T1 completes execution, T2 thread starts executing.</para>
    <para/>
  </sect1>
</article>
